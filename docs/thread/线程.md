# 线程

[toc]

## Thread源码

```java
public class Thread implements Runnable {
      public synchronized void start() {
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
        group.add(this);
        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
            }
        }
    }

    private native void start0();
  
  //我们会重写run方法，会调回我们自己写的run方法中
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
}
```

- 实现了Runnable，重写了run方法，其实只是自动帮我们做了Runnable的代理，我们不用传入Runnable对象就可以创建线程对象
  - new ExtendThread().start;
  - new Thread(new ImplementRunnable()).start();
- 调用Thread.start方法，`native void start0();`start0方法会去向操作系统申请线程，然后回调到我们的run方法

## 线程创建三种方式

其实继承Thread与/实现Runnable方法，没有本质上的区别，Thread中的start0，都会回调到Thread类的run方法，继承Thread，start0是以this的身份，执行代码，回调回来直接调用到我们继承了Thread的子类，实现Runnable方法会被Thread静态代理，判断target不为空，调用target执行

* 继承Thread
  - 我们继承自thread，ExtendThread=Thread的子类，拥有Thread的所有方法且重写其run方法，所以我们调用调用`extendThread.start();`自己类的start方法，父类的Thread中的start0方法申请到线程，回调回run方法，就会调用到ExtendThread类的run方法

```java
public class ExtendThread extends Thread{

    @Override
    public void run() {
        for (int i = 0; i < 2000; i++) {
            System.out.println("my-thread-"+i);
        }
    }

    /**
     * 主线程，多个线程是交替执行的
     * 注意：线程开启不一定立即执行，由cpu安排调度执行
     */
    public static void main(String[] args) {
        //创建线程对象，调用run方法，主线程与副线程是交替执行
        ExtendThread extendThread = new ExtendThread();
        extendThread.start();
        for (int i = 0; i < 2000; i++) {
            System.out.println("main thread-"+i);
        }
    }
}
```

启动程序后，系统中会有2条线程，在并发同时执行任务，main为主线程，执行主任务，Thread-0为extendThread.start();向系统申请到的线程，在后台并发执行任务

![image-20220730175545748](/Users/hhh/Library/Application Support/typora-user-images/image-20220730175545748.png)

* 实现Runnable，Java是单继承，所以推荐使用实现Runnable的方式创建线程，避免继承局限性

```java
public class ImplementRunnable implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 2000; i++) {
            System.out.println("ImplementRunnable Thread:"+i);
        }
    }

    public static void main(String[] args) {
        new Thread(new ImplementRunnable()).start();
        for (int i = 0; i < 2000; i++) {
            System.out.println("MAIN Thread:"+i);
        }
        
    }
}
```

* - new Thread(new ImplementRunnable()).start(); 方法，其实是向Thread类传递一个参数，Thread类，做了一层简单的静态代理，将new ImplementRunnable()参数作为target，存入Thread类的成员属性中，start0回调回来的时候，调用Thread的run方法，Thread判断target不为空，调用target的run方法，执行线程任务代码

```java
    /* What will be run. */
    private Runnable target;

public Thread(Runnable target) {
        this(null, target, "Thread-" + nextThreadNum(), 0);
    }

    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
```

* 实现Callable
  - 需要返回值类型
  - 需要重新call方法，需要抛出异常
  - 创建目标对象
  - 创建执行服务
  - 提交执行
  - 获取结果
  - 关闭服务

```java
public class ThreadCallable implements Callable {
    @Override
    public Boolean call() throws Exception {
        System.out.println("xxx");
        return true;
    }
    public static void main(String[] args)throws Exception {
        //开启线程池
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        //提交任务
        Future submit = executorService.submit(new ThreadCallable());
        //获取任务执行结果
        submit.get();
        //任务完成，关闭线程池，不然线程池中会有一个阻塞队列，线程池会阻塞，等待任务
        if (submit.isDone()){
            executorService.shutdownNow();
        }
    }
}
```

## 龟兔赛跑模拟多线程

```java
public class Race implements Runnable{
    private static String WINNER;

    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {
            boolean flag = gameOver(i);
            if (flag){
                break;
            }
            System.out.println(Thread.currentThread().getName()+"跑了-"+i);
        }
    }
    private boolean gameOver(int i) {
        if (StringUtils.hasLength(WINNER)){
            System.out.println("winner is "+WINNER);
            return true;
        }
        if (i>=100){
            WINNER=Thread.currentThread().getName();
            return true;
        }
        return false;
    }
    /**
     * 龟兔赛跑
     */
    public static void main(String[] args) {
        //规定同一个赛道
        Race race = new Race();
        new Thread(race,"兔子").start();
        new Thread(race,"乌龟鬼").start();
    }
}

```

## 线程的五大状态



![image-20220729161305993](/Users/hhh/Library/Application Support/typora-user-images/image-20220729161305993.png)





![image-20220729163029636](/Users/hhh/Library/Application Support/typora-user-images/image-20220729163029636.png)

### 线程停止

 * 不推荐使用JDK提供的stop方法，JDK也已经将stop方法废弃
 * 推荐线程自己判断执行完成后停止，例如本例子中

```java
public class StopThread implements Runnable {

    private static Boolean FLAG=Boolean.TRUE;

    @Override
    public void run(){
        while (FLAG){
            System.out.println("thread execute");
            //给个标识让线程自然停止
            FLAG=false;
        }
    }
    /**
     * 停止线程
     * - 不推荐使用JDK提供的stop方法，JDK也已经将stop方法废弃
     * - 推荐线程自己判断执行完成后停止，例如本例子中
     */
    public static void main(String[] args) {
        new Thread(new StopThread()).start();
    }
}
```

### 线程休眠

- sleep时间达到以后线程进入就绪状态，等待CPU调度执行
- 每个对象都有一个锁，sleep不会释放对象锁

### 线程礼让

- 礼让线程，当前正在执行的线程暂停，但不阻塞
- 将线程从运行状态转为就绪状态
- 让CPU重新调度，礼让不一定成功，要看CPU心情

### 线程强制join

- join何必线程，待此线程执行完成后，执行其他线程，其他线程阻塞
- 可以想象为插队

### 观测线程状态

可以通过thread.getState()获取线程状态

```java
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```

```java
public static void main(String[] args) {
    Thread thread = new Thread(new SleepThread());
    thread.start();
    Thread.State state = thread.getState();
}
```

### 线程优先级

线程优先级越高，并不代表一定会最优先执行，还是需要让CPU进行调度，但是优先级越高代表优先执行的权重越高

```java
    /**
     * The minimum priority that a thread can have.
     */
    public static final int MIN_PRIORITY = 1;

    /**
     * The default priority that is assigned to a thread.
     */
    public static final int NORM_PRIORITY = 5;

    /**
     * The maximum priority that a thread can have.
     */
    public static final int MAX_PRIORITY = 10;
```

## FutureTask

### Future

```java
public interface Future<V> {

    /**
     * 取消
     */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
     * 是否取消
     */
    boolean isCancelled();

    /**
     * 是否完成
     */
    boolean isDone();
    /**
     * 获取执行结果
     */
    V get() throws InterruptedException, ExecutionException;
    /**
     * 带超时操作的获取执行结果
     */
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

### RunnableFuture

- 继承了Runnable，说明其重写了run方法，将这个任务提交到线程池，线程池调度执行，调用start0，会调用回本类的run方法，执行我们自己的线程逻辑

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```

### FutureTask

- 实现RunnableFuture，既能run，又能获取线程未来执行结果
- 相当于在线程外，又包了一层，用于执行FutureTask的run方法的逻辑，run方法
  - 例如，调用get()，是我们的主线程在调用get，进入get方法的自旋，主线程会被park，等待FutureTask 的run方法，执行完成，调用finishCompletion()，将返回值放入outcome，unpark唤醒主线程，主线程拿到结果，返回给用户

```java
public class FutureTask<V> implements RunnableFuture<V> {
    /**
     * 当前任务状态
     */
    private volatile int state;
    private static final int NEW          = 0;//当前任务尚未执行
    private static final int COMPLETING   = 1;//当前任务尚未完全结束，一种临界状态
    private static final int NORMAL       = 2;//当前任务正常结束
    private static final int EXCEPTIONAL  = 3;//当前任务执行过程中发生了异常，内部封装的callable.run向上抛出异常了
    private static final int CANCELLED    = 4;//当前任务被取消，当任务提交到线程池一直未进行执行，可以使用cancelled将任务取消
    private static final int INTERRUPTING = 5;//当前任务正在中断
    private static final int INTERRUPTED  = 6;//当前任务已中断
  
    /** 使用装饰者模式伪装成callable接口 */
    private Callable<V> callable;
    /**
     * 正常情况下，任务正常执行结束，outcome保存执行结果，就是callable的返回值
     * 非正常情况，callable向上抛出异常，outcome保存异常
     */    
    private Object outcome; 
    //当前任务被线程执行期间，保存当前执行任务线程对象的引用
    private volatile Thread runner;  
    //因为会有很多线程会去get当前任务的结果，所以这里使用了一个栈
    private volatile WaitNode waiters;  
    /**
     * Callable创建FutureTask
     */    
    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        //程序员自己传入的callable对象，callable的返回值可能是一个有值也有可能为null，为null，是因为在submit的时候，传入了一个Runnable，默认返回值为null
        this.callable = callable;
        this.state = NEW;//设置当前任务状态为new
    }

    /**
     * Runnable创建FutureTask
     */
    public FutureTask(Runnable runnable, V result) {
        //将runnable，通过适配器封装为了callable，传入的结果会在线程执行完成后，返回，传入什么返回什么
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // 设置执行状态为new
    }  
  
    private static final class RunnableAdapter<T> implements Callable<T> {
        private final Runnable task;
        private final T result;
        RunnableAdapter(Runnable task, T result) {
            this.task = task;
            this.result = result;
        }
        public T call() {
            task.run();//运行任务
            return result;//将传入的值在返回回去，并没有使用线程执行任务的结果返回
        }
        public String toString() {
            return super.toString() + "[Wrapped task = " + task + "]";
        }
    }  

}
```

#### run()

```java
    public void run() {
      //state != NEW 代表任务已经被执行过了，或者被cancel了，总之非new状态的任务线程就不处理了，直接返回
      //!RUNNER.compareAndSet(this, null, Thread.currentThread()) false代表线程抢占失败，会返回
        if (state != NEW ||
            !RUNNER.compareAndSet(this, null, Thread.currentThread()))
            return;
        try {
            //执行到这里，当前task一定是new，且抢占线程成功，这个callable就是程序员自己封装逻辑的callable/runable
            Callable<V> c = callable;
            //c != null判断任务不为空，防止程序员传了一个null，且线程为new，防止外部线程cancel掉这个线程
            if (c != null && state == NEW) {
              //线程执行结果引用
                V result;
              //true表示callable.run代码执行成功，代码没有异常，false代表程序员代码抛出异常
                boolean ran;
                try {
                  //调用程序员自己封装的代码
                    result = c.call();
                  //正常执行，未抛出任何异常，run设置为true
                    ran = true;
                } catch (Throwable ex) {
                  //设置返回值为null
                    result = null;
                  //执行失败，抛出异常，run设置为false
                    ran = false;
                  //将异常设置到outcome中，将状态修改为COMPLETING，outcome引用的是，callable向上抛出的异常，将任务状态设置为EXCEPTIONAL
                    setException(ex);
                }
                if (ran)
                  //说明当前c.call正常执行，设置结果值到outcome，设置任务状态为COMPLETING成功之后，就会将线程任务设置为NORMAL状态，线程正常结束，会调用finishCompletion()，通知park的线程重新启动
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
          //判断线程是否为中断中
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }  
  
```

#### get()与awaitDone入队

```java
		//记得思考场景，多个线程同时获取，等待这个线程任务执行结果
		public V get() throws InterruptedException, ExecutionException {
      //获取当前任务状态
        int s = state;
      //小于COMPLETING状态，未执行/正在执行/正在完成/，调用get的外部线程会被阻塞在get方法上，那么怎么实现阻塞呢？
        if (s <= COMPLETING)
          //返回task当前状态，可能当前线程已经在里面park过一会了
            s = awaitDone(false, 0L);
      //向外报告结果
        return report(s);
    }


		//timed属性为带不带超时，WaitNode入队
    private int awaitDone(boolean timed, long nanos)
        throws InterruptedException {
        long startTime = 0L;
      //引用当前线程，封装成WaitNode对象
        WaitNode q = null;
      //表示当前WaitNode对象有没有压栈
        boolean queued = false;
        for (;;) {
          //在最后一步else，线程会被park，如果被唤醒，线程会再次进入自旋，
          //线程是被其他线程使用un park线程唤醒，代码会正常执行
            int s = state;
          //s > COMPLETING说明当前任务已经有结果了，可能是好，也可能是坏
            if (s > COMPLETING) {
              //条件成立说明当前线程已经创建过node了，此时需要将nod.thread=null
                if (q != null)
                    q.thread = null;
              //执行返回当前状态
                return s;
            }
          //表示当前这个任务快完成了，让当前线程释放CPU，进行下一次抢占CPU
            else if (s == COMPLETING)
                //释放CPU运行权限，进入下一次争抢CPU
                Thread.yield();
          //Thread.interrupted()条件成立，说明当前线程是被其他线程使用中断唤醒的，需要抛出InterruptedException异常
            else if (Thread.interrupted()) {
              //将当前node节点从阻塞队列进行出队
                removeWaiter(q);
              //向get方法抛出中断异常
                throw new InterruptedException();
            }
          //1.表示第一次自旋，当前线程还未创建WaitNode对象，为当前线程创建WaitNode对象
            else if (q == null) {
                if (timed && nanos <= 0L)
                    return s;
                q = new WaitNode();
            }
          //第二次自旋，当前线程创建了WaitNode对象，但是还没入队，需要做入队相关操作
            else if (!queued)
              //将当前线程WaitNode节点next指向队列的头节点，waiters一直指向队列的头，修改头指针指向节点
                q.next = waiters;
          		//cas方式设置waiters引用指向当前线程node，成功的话queued=true，false的话可能是其他线程先一步入队了，需要再次自旋尝试，知道入队成功为止
                queued = WAITERS.weakCompareAndSet(this,waiters , q);
          //第三次自旋会来到这里，如果我们不需要超时时间获取，会进入下面的else
            else if (timed) {
                final long parkNanos;
                if (startTime == 0L) { // first time
                    startTime = System.nanoTime();
                    if (startTime == 0L)
                        startTime = 1L;
                    parkNanos = nanos;
                } else {
                    long elapsed = System.nanoTime() - startTime;
                    if (elapsed >= nanos) {
                        removeWaiter(q);
                        return state;
                    }
                    parkNanos = nanos - elapsed;
                }
                // nanoTime may be slow; recheck before parking
                if (state < COMPLETING)
                  //
                    LockSupport.parkNanos(this, parkNanos);
            }
            else
              //当前get操作的线程，就会被park，线程状态会变为waiting状态，相当于休眠了，除非有其他线程将其唤醒或者将其中断
                LockSupport.park(this);
        }
    }

```



#### removeWaiter()出队

```java
private void removeWaiter(WaitNode node) {
    if (node != null) {
        node.thread = null;
        retry:
        for (;;) {          // restart on removeWaiter race
            for (WaitNode pred = null, q = waiters, s; q != null; q = s) {
                s = q.next;
                if (q.thread != null)
                    pred = q;
                else if (pred != null) {
                    pred.next = s;
                    if (pred.thread == null) // check for race
                        continue retry;
                }
                else if (!WAITERS.compareAndSet(this, q, s))
                    continue retry;
            }
            break;
        }
    }
}
```



#### report

```java
    private V report(int s) throws ExecutionException {
      //正常outcome存的是线程任务的执行结果，异常的话，outcome存的是线程执行的异常
        Object x = outcome;
      //判断线程状态，正常的话，直接返回线程执行结果
        if (s == NORMAL)
            return (V)x;
      //大于等于CANCELLED，就是被取消状态，直接抛出状态
        if (s >= CANCELLED)
            throw new CancellationException();
      //说明callable代码实现中，任务执行抛出异常
        throw new ExecutionException((Throwable)x);
    }



```

#### finishCompletion

```java
    private void finishCompletion() {
      //q指向WaitNode链表头节点
        for (WaitNode q; (q = waiters) != null;) {
          //使用CAS设置WAITERS为null，怕外部线程使用cancel方法
            if (WAITERS.weakCompareAndSet(this, q, null)) {
                for (;;) {
                  //获取当前WaitNode节点封装的thread节点
                    Thread t = q.thread;
                    if (t != null) {
                      //当前线程不为空，将节点线程设置为null
                        q.thread = null;
                      //唤醒当前线程
                        LockSupport.unpark(t);
                    }
                  //处理当前节点的下一个节点
                    WaitNode next = q.next;
                  //下一个节点如果为空，代表当前处理为最后一个节点，直接退出，否则继续循环处理节点
                    if (next == null)
                        break;
                    q.next = null; // unlink to help gc
                    q = next;
                }
                break;
            }
        }

        done();
      //将callable设置为空
        callable = null;        // to reduce footprint
    }
```

#### cancel

```java

public boolean cancel(boolean mayInterruptIfRunning) {
  //state == NEW且当前任务处于运行中或者线程池队列中
    if (!(state == NEW && STATE.compareAndSet
          (this, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))
        return false;
    try {    
      //是否需要给当前正在执行的线程发送一个中断信号
        if (mayInterruptIfRunning) {
            try {
                Thread t = runner;
              //是null的时候，线程还在任务队列中，还没有被线程获取到
                if (t != null)
                  //t不为空，有线程正在执行任务，给线程一个中断信号
                    t.interrupt();
            } finally {
              //设置任务状态为中断完成
                STATE.setRelease(this, INTERRUPTED);
            }
        }
    } finally {
      //将线程唤醒，唤醒所有get阻塞线程
        finishCompletion();
    }
    return true;
}
```

## 线程池

### 使用Java Executors工具创建线程池

使用Java Executors工具创建线程池，无法指定线程池的核心参数，无法对线程池进行更好的控制

```java
public class Test {
    public static void main(String[] args) {
        //只能配置核心线程数
        ExecutorService executorService = Executors.newFixedThreadPool(1);
    }
}
```

### ThreadPoolExecutor

Java中使用的线程池为ThreadPoolExecutor，我们常说的线程池7大核心参数，其实就是ThreadPoolExecutor类的构造方法

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
    }
```

- corePoolSize：核心线程数
- maximumPoolSize：最大线程数
- keepAliveTime：线程空闲时间
- TimeUnit：线程空闲时间单位
- workQueue：阻塞队列，细粒度控制线程，可以在如下4个中选择使用的线程队列
  - ArrayBlockingQueue：无序
  - LinkedBlockingQueue：有序
  - PriorityBlockingQueue：优先级
  - SynchronousQueue：阻塞

- threadFactory：线程工厂，可以指定线程名称，后续例如出现频繁GC，就可以通过线程名称定位出现问题的线程
- handler：拒绝策略
  - AbortPolicy
  - CallerRunsPolicy
  - DiscardOldestPolicy
  - DiscardPolicy

### 线程池核心参数如何合理设置？

#### corePoolSize

- 核心线程会一直存活，即使没有任务需要执行。
- 当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理。
- 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭。

如何设置好的前提我们要很清楚的知道`CPU密集型`和`IO密集型`的区别

##### CUP密集型

`CPU密集型`也叫`计算密集型`，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，**CPU Loading 很高，程序运行的大部分时间是CPU运算**

##### IO密集型

IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，**大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低**。

##### 机器核数

```java
System.out.println(Runtime.getRuntime().availableProcessors());
```

##### 计算公式

- CPU密集型：corePoolSize = CPU核数 + 1

- IO密集型：corePoolSize = CPU核数 \* 2

#### maximumPoolSize

需要设置最大线程数🟰核心线程数，避免CPU频繁的进行上下文切换

- 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务。
- 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常。

#### keepAliveTime

- 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize。
- 如果allowCoreThreadTimeout=true，则会直到线程数量=0。

#### workQueue

- 当核心线程数达到最大时，新任务会放在队列中排队等待执行

#### RejectedExecutionHandler

两种情况会拒绝处理任务：

- 当线程数已经达到maxPoolSize，且队列已满，会拒绝新任务。
- 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务。线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常。

ThreadPoolExecutor 采用了策略的设计模式来处理拒绝任务的几种场景，这几种策略模式都实现了RejectedExecutionHandler 接口

- AbortPolicy ：丢弃任务，抛运行时异常，不指定，默认为AbortPolicy的拒绝策略
- CallerRunsPolicy：执行任务。
- DiscardPolicy：忽视，什么都不会发生。
- DiscardOldestPolicy：从队列中踢出最先进入队列（最后一个执行）的任务。

## 线程池执行流程

|                        线程池执行流程                        |
| :----------------------------------------------------------: |
| ![image-20220726190031962](/Users/hhh/Library/Application Support/typora-user-images/image-20220726190031962.png) |

### 例子

拿饭店中举例子

- 饭店：线程池
- 位子：线程
- 人多先排队：阻塞队列
- 在空闲处加桌子，增加位置，没人再回收：创建最大线程数中的线程
- 等位位置也满了：拒绝策略

### 线程池核心属性

```java
//1.声明当前线程池状态；2.声明线程池的线程数
//高3位：线程状态 低29位：线程池中的线程个数
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//指的是一个Integer占4个字节，32位，提供这个方便后面做位运算
private static final int COUNT_BITS = Integer.SIZE - 3;
//通过运算得到最大线程容量
//1左移29位后减一
//0000 0000 0000 0000 0000 0001	1
//0010 0000 0000 0000 0000 0000	左移29位 - 1
//0001 1111 1111 1111 1111 1111  这个代表：高3位：线程状态 低29位：线程池中的线程个数
private static final int COUNT_MASK = (1 << COUNT_BITS) - 1;

// 线程池的5种状态 
//1111 1111 1111 1111 1111 1111 	-1 左移 29位
//1110 0000 0000 0000 0000 0000   111代表RUNNING，正常接收任务
private static final int RUNNING    = -1 << COUNT_BITS;
//000 代表线程池为SHUTDOWN状态，不接受新任务，但是内部还会处理阻塞队列中的任务，正常进行中的任务也会继续执行
private static final int SHUTDOWN   =  0 << COUNT_BITS;
//1往左移动29位 001 不接受新任务，不处理阻塞队列中的任务，中断进行中的任务
private static final int STOP       =  1 << COUNT_BITS;
//2左移动29位 010 过渡状态，代表线程即将关闭
private static final int TIDYING    =  2 << COUNT_BITS;
//3左移动29位 011 线程池真正关闭 要执行TERMINATED方法
private static final int TERMINATED =  3 << COUNT_BITS;

// 取反，得到线程池的状态
private static int runStateOf(int c)     { return c & ~COUNT_MASK; }
//得到当前线程池的线程数量
private static int workerCountOf(int c)  { return c & COUNT_MASK; }
//为后续更新线程数值做准备
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### 线程池状态变化

![image-20220726211129326](/Users/hhh/Library/Application Support/typora-user-images/image-20220726211129326.png) 



### ThreadPoolExecutor线程池源码

#### execute

```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
      //拿到32位int
        int c = ctl.get();
      //工作线程数 < 核心线程数
        if (workerCountOf(c) < corePoolSize) {
          //进到if，代表可以创建核心线程数
            if (addWorker(command, true))
              //使用核心线程数，直接返回
                return;
          //走到这，代表获取核心线程数失败，可能有并发操作，有线程获取失败了
            c = ctl.get();
        }
      //判断线程池是否还在RUNNING，将任务添加到阻塞队列中
        if (isRunning(c) && workQueue.offer(command)) {
          //再次获取ctl，重新检查，是否为RUNNING，考虑并发问题
            int recheck = ctl.get();
          //不是RUNNING，移除任务
            if (! isRunning(recheck) && remove(command))
              //直接执行拒绝策略
                reject(command);
          //获取现在正在工作的线程池个数，如果线程池处于RUNNING状态，且工作线程为0
            else if (workerCountOf(recheck) == 0)
              //阻塞队列有任务，但是没有工作线程，这时候就需要添加一个任务为空的工作线程去处理阻塞队列中的任务
                addWorker(null, false);
        }
      //创建非核心线程处理任务
        else if (!addWorker(command, false))
          //
            reject(command);
    }
```

#### addWorker

```java
private boolean addWorker(Runnable firstTask, boolean core) {
  //goto，多个for循环的退出，使用goto是为了，在不加锁的情况下保证线程安全
        retry:
  //这边的for循环，只是做了大量的判断，给工作线程数标识➕1，没有其他操作，之所以写的这么复杂，是为了在不加锁的情况下保证线程安全
  //获取32位的int值（线程池状态），进入死循环
        for (int c = ctl.get();;) {
            // 校验非运行时状态
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP)
                    //传null，当前没有工作线程，需要创建一个空任务
                    //firstTask == null阻塞队列有任务，但是没有工作线程，这时候就需要添加一个任务为空的工作线程去处理阻塞队列中的任务
                    || firstTask != null
                    //阻塞队列为空
                    || workQueue.isEmpty()))
              //构建工作线程失败，直接退出
                return false;
//前面校验通过，进入第二次死循环
            for (;;) {
              //工作线程个数【线程池最大线程容量】
              //core为外部传入的，true代表创建核心线程创建任务，false代表使用核心线程外的最大线程创建任务
              //判断工作线程数是否大于核心线程数或者大于最大线程数，大于的话，也不创建，构建工作线程失败，直接退出
                if (workerCountOf(c)
                    >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))
                  //构建工作线程失败，直接退出
                    return false;
              //使用CAS，将工作线程数+1
                if (compareAndIncrementWorkerCount(c))
                  //成功就退出外侧for循环
                    break retry;
              //CAS失败，会重新获取CTL，失败原因只有一个，有线程并发操作
                c = ctl.get();  // Re-read ctl
              //判断线程状态，是否有变化，是否为非RUNNING
                if (runStateAtLeast(c, SHUTDOWN))
                  //是的话直接退出到外层循环，在走一次
                    continue retry;
              //如果为running，在内层在循环一次就行了
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
//开始真正创建worker工作线程
  //worker开始=false
        boolean workerStarted = false;
  //worker添加=false
        boolean workerAdded = false;
        Worker w = null;
        try {
          //创建worker对象，传入工作任务
            w = new Worker(firstTask);
            final Thread t = w.thread;
          //获取出的任务不为空
            if (t != null) {
              //获取线程池的全局锁，避免当前线程在添加任务时，别的线程进入操作，结束了线程池，所以加锁，要想结束线程池，需要先获取到这个全局锁
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                  //获取线程池状态
                    int c = ctl.get();
                  //线程还未运行，状态就改变了，就要抛出非法的线程状态异常，firstTask == null是处理阻塞队列有任务，但是没有工作线程，这时候就需要添加一个任务为空的工作线程去处理阻塞队列中的任务
                    if (isRunning(c) ||
                        (runStateLessThan(c, STOP) && firstTask == null)) {
                        if (t.getState() != Thread.State.NEW)
                            throw new IllegalThreadStateException();
                      //添加worker
                        workers.add(w);
                      //添加worker工作线程成功
                        workerAdded = true;
                      //如果工作线程数，大于之前记录的线程数，就替换一下线程数，代表线程数已经更新成功
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                    }
                } finally {
                  //释放ReentrantLock
                    mainLock.unlock();
                }
                if (workerAdded) {
                  //添加成功，启动工作线程
                    t.start();
                  //启动工作线程成功
                    workerStarted = true;
                }
            }
        } finally {
          //如果启动工作线程失败，从工作线程workers中移除添加的worker工作线程，重置线程数
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

#### Worker封装

线程中放的runnable，其实就是worker对象，当线程.start的时候，其实就是执行的worker的run方法

```java
//实现了Runnable，那么肯定重写了Run方法
    private final class Worker extends AbstractQueuedSynchronizer implements Runnable
    {
        /**
         * This class will never be serialized, but we provide a
         * serialVersionUID to suppress a javac warning.
         */
        private static final long serialVersionUID = 6138294804551838833L;

        /** Thread this worker is running in.  Null if factory fails. */
        @SuppressWarnings("serial") // Unlikely to be serializable
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        @SuppressWarnings("serial") // Not statically typed as Serializable
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;
      //有参构造，将线程池的任务传入给worker
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
          //核心代码，调用工作代码的start，走的是worker的run方法
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker. */
        public void run() {
            runWorker(this);
        }
    }
```

#### runWorker

```java
final void runWorker(Worker w) {
  //获取当前线程
    Thread wt = Thread.currentThread();
  //拿到传入的任务
    Runnable task = w.firstTask;
  //AQS
    w.firstTask = null;
    w.unlock(); // allow interrupts
  //标识为true
    boolean completedAbruptly = true;
    try {
      //如果任务不为空 || 如果任务为空，就从阻塞队列中获取任务
      //task = getTask()阻塞队列就在这里阻塞的，等待线程池空闲，会调用park方法，进行线程阻塞
        while (task != null || (task = getTask()) != null) {
          //加锁，避免线程池被shutdown
            w.lock();
          //判断当前线程池状态是否大于等于STOP，状态为TERMINATED
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
              //中断该线程
                wt.interrupt();
            try {
              //执行任务前操作，模板方法，可以自己重写
                beforeExecute(wt, task);
                try {
                  //开始执行任务
                    task.run();
                  //执行任务后操作，模板方法，可以自己重写
                    afterExecute(task, null);
                } catch (Throwable ex) {
                  //执行任务后操作，模板方法，可以自己重写
                    afterExecute(task, ex);
                    throw ex;
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

#### submit

```java
public <T> Future<T> submit(Callable<T> task) {
    if (task == null) throw new NullPointerException();
  //将传入的task封装为一个RunnableFuture对象，
    RunnableFuture<T> ftask = newTaskFor(task);
  //将任务提交给线程池
    execute(ftask);
    return ftask;
}

    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        return new FutureTask<T>(callable);
    }

		//FutureTask构造方法，加callable存下，然后将任务状态设置为NEW
    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }
```

## FutureTask使用示例

FutureTask是配合线程池使用的，将任务submit到线程池中，线程池安排线程执行

### 实例一

```java
public class FutureDemo {
      public static void main(String[] args) {
          ExecutorService executorService = Executors.newCachedThreadPool();
          Future future = executorService.submit(new Callable<Object>() {
              @Override
              public Object call() throws Exception {
                  Long start = System.currentTimeMillis();
                  while (true) {
                      Long current = System.currentTimeMillis();
                     if ((current - start) > 1000) {
                         return 1;
                     }
                 }
             }
         });
         try {
             Integer result = (Integer)future.get();
             System.out.println(result);
         }catch (Exception e){
             e.printStackTrace();
         }
     }
}

```

### 实例一执行流程

1. Main线程开启线程池
2. Main提交任务，返回任务句柄

![image-20220731160912165](/Users/hhh/Library/Application Support/typora-user-images/image-20220731160912165.png)

3. 主线程返回的Future对象是从submit方法返回，newTaskFor，新建了一个FutureTask对象，并返回，`FutureTask<V> implements RunnableFuture<V> `，FutureTask重写了run方法，所以提交到线程池中的任务，等会会回调回Future Task的run，将任务交给线程池进行execute

![image-20220731161052452](/Users/hhh/Library/Application Support/typora-user-images/image-20220731161052452.png)

![image-20220731161152457](/Users/hhh/Library/Application Support/typora-user-images/image-20220731161152457.png)

![image-20220731161349281](/Users/hhh/Library/Application Support/typora-user-images/image-20220731161349281.png)



4. 将提交的任务，添加到工作队列中，**注意：是将FutureTask对象提交到了线程池中，然后回调到了FetureTask对象，由FetureTask对象，调用call方法真正执行任务**

![image-20220731161824795](/Users/hhh/Library/Application Support/typora-user-images/image-20220731161824795.png)

![image-20220731162142639](/Users/hhh/Library/Application Support/typora-user-images/image-20220731162142639.png)

![image-20220731162532398](/Users/hhh/Library/Application Support/typora-user-images/image-20220731162532398.png)

5.开启新线程，Thread-1，线程回调到申请线程的FeatureTask类run方法，同时，Main线程继续往下执行，调用get方法，最终会在awaitDone中，被park住，等待任务执行完成后唤醒

![image-20220731163239492](/Users/hhh/Library/Application Support/typora-user-images/image-20220731163239492.png)

![image-20220731163322700](/Users/hhh/Library/Application Support/typora-user-images/image-20220731163322700.png)

## FutureTask实践

FutureTask需要一个线程池，现使用tomcat开辟线程池的方式，开启线程

- 代码抄的embed tomcat org.apache.tomcat.util.net.AbstractEndpoint#createExecutor()
- 如果需要对tomcat进行调优，那么该项目的线程池参数，也会根据tomcat 的配置进行调整
- 该类为懒汉式单例，使用synchronized保证本有状态的bean单例线程安全

```java
@Component
public class ContractCenterThreadExecutor {
    @Autowired
    private ApplicationContext applicationContext;
    private ThreadPoolExecutor executor = null;
    @Autowired
    private ServerProperties serverProperties;

    public synchronized ExecutorService getExecutorService() {
        if (executor != null) {
            return executor;
        }
        TaskQueue taskqueue = new TaskQueue();
        ServerProperties.Tomcat.Threads threads = serverProperties.getTomcat().getThreads();
        boolean daemon = true;
        TaskThreadFactory tf = new TaskThreadFactory(applicationContext.getId() + "-exec-", daemon, Thread.NORM_PRIORITY);
        executor = new ThreadPoolExecutor(threads.getMinSpare(), threads.getMax(), 60, TimeUnit.SECONDS, taskqueue, tf);
        taskqueue.setParent(executor);
        return executor;
    }
}
```

### feign使用

- SynchronousMethodHandler，feign.SynchronousMethodHandler#executeAndDecode方法，对request进行组装时，需要将线程变量设置到新开启的线程中
- feign.SynchronousMethodHandler#targetRequest 组装feign request，会对注册到系统的RequestInterceptor拦截器执行
- 在编写callback时，需要将当前线程变量设置到新开线程的thread local中

![image-20221116164730777](/Users/hhh/Library/Application Support/typora-user-images/image-20221116164730777.png)

## BlockingQueue





