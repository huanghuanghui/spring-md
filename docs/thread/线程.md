# çº¿ç¨‹

[toc]

## Threadæºç 

```java
public class Thread implements Runnable {
      public synchronized void start() {
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
        group.add(this);
        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
            }
        }
    }

    private native void start0();
  
  //æˆ‘ä»¬ä¼šé‡å†™runæ–¹æ³•ï¼Œä¼šè°ƒå›æˆ‘ä»¬è‡ªå·±å†™çš„runæ–¹æ³•ä¸­
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
}
```

- å®ç°äº†Runnableï¼Œé‡å†™äº†runæ–¹æ³•ï¼Œå…¶å®åªæ˜¯è‡ªåŠ¨å¸®æˆ‘ä»¬åšäº†Runnableçš„ä»£ç†ï¼Œæˆ‘ä»¬ä¸ç”¨ä¼ å…¥Runnableå¯¹è±¡å°±å¯ä»¥åˆ›å»ºçº¿ç¨‹å¯¹è±¡
  - new ExtendThread().start;
  - new Thread(new ImplementRunnable()).start();
- è°ƒç”¨Thread.startæ–¹æ³•ï¼Œ`native void start0();`start0æ–¹æ³•ä¼šå»å‘æ“ä½œç³»ç»Ÿç”³è¯·çº¿ç¨‹ï¼Œç„¶åå›è°ƒåˆ°æˆ‘ä»¬çš„runæ–¹æ³•

## çº¿ç¨‹åˆ›å»ºä¸‰ç§æ–¹å¼

å…¶å®ç»§æ‰¿Threadä¸/å®ç°Runnableæ–¹æ³•ï¼Œæ²¡æœ‰æœ¬è´¨ä¸Šçš„åŒºåˆ«ï¼ŒThreadä¸­çš„start0ï¼Œéƒ½ä¼šå›è°ƒåˆ°Threadç±»çš„runæ–¹æ³•ï¼Œç»§æ‰¿Threadï¼Œstart0æ˜¯ä»¥thisçš„èº«ä»½ï¼Œæ‰§è¡Œä»£ç ï¼Œå›è°ƒå›æ¥ç›´æ¥è°ƒç”¨åˆ°æˆ‘ä»¬ç»§æ‰¿äº†Threadçš„å­ç±»ï¼Œå®ç°Runnableæ–¹æ³•ä¼šè¢«Threadé™æ€ä»£ç†ï¼Œåˆ¤æ–­targetä¸ä¸ºç©ºï¼Œè°ƒç”¨targetæ‰§è¡Œ

* ç»§æ‰¿Thread
  - æˆ‘ä»¬ç»§æ‰¿è‡ªthreadï¼ŒExtendThread=Threadçš„å­ç±»ï¼Œæ‹¥æœ‰Threadçš„æ‰€æœ‰æ–¹æ³•ä¸”é‡å†™å…¶runæ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬è°ƒç”¨è°ƒç”¨`extendThread.start();`è‡ªå·±ç±»çš„startæ–¹æ³•ï¼Œçˆ¶ç±»çš„Threadä¸­çš„start0æ–¹æ³•ç”³è¯·åˆ°çº¿ç¨‹ï¼Œå›è°ƒå›runæ–¹æ³•ï¼Œå°±ä¼šè°ƒç”¨åˆ°ExtendThreadç±»çš„runæ–¹æ³•

```java
public class ExtendThread extends Thread{

    @Override
    public void run() {
        for (int i = 0; i < 2000; i++) {
            System.out.println("my-thread-"+i);
        }
    }

    /**
     * ä¸»çº¿ç¨‹ï¼Œå¤šä¸ªçº¿ç¨‹æ˜¯äº¤æ›¿æ‰§è¡Œçš„
     * æ³¨æ„ï¼šçº¿ç¨‹å¼€å¯ä¸ä¸€å®šç«‹å³æ‰§è¡Œï¼Œç”±cpuå®‰æ’è°ƒåº¦æ‰§è¡Œ
     */
    public static void main(String[] args) {
        //åˆ›å»ºçº¿ç¨‹å¯¹è±¡ï¼Œè°ƒç”¨runæ–¹æ³•ï¼Œä¸»çº¿ç¨‹ä¸å‰¯çº¿ç¨‹æ˜¯äº¤æ›¿æ‰§è¡Œ
        ExtendThread extendThread = new ExtendThread();
        extendThread.start();
        for (int i = 0; i < 2000; i++) {
            System.out.println("main thread-"+i);
        }
    }
}
```

å¯åŠ¨ç¨‹åºåï¼Œç³»ç»Ÿä¸­ä¼šæœ‰2æ¡çº¿ç¨‹ï¼Œåœ¨å¹¶å‘åŒæ—¶æ‰§è¡Œä»»åŠ¡ï¼Œmainä¸ºä¸»çº¿ç¨‹ï¼Œæ‰§è¡Œä¸»ä»»åŠ¡ï¼ŒThread-0ä¸ºextendThread.start();å‘ç³»ç»Ÿç”³è¯·åˆ°çš„çº¿ç¨‹ï¼Œåœ¨åå°å¹¶å‘æ‰§è¡Œä»»åŠ¡

![image-20220730175545748](/Users/hhh/Library/Application Support/typora-user-images/image-20220730175545748.png)

* å®ç°Runnableï¼ŒJavaæ˜¯å•ç»§æ‰¿ï¼Œæ‰€ä»¥æ¨èä½¿ç”¨å®ç°Runnableçš„æ–¹å¼åˆ›å»ºçº¿ç¨‹ï¼Œé¿å…ç»§æ‰¿å±€é™æ€§

```java
public class ImplementRunnable implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 2000; i++) {
            System.out.println("ImplementRunnable Thread:"+i);
        }
    }

    public static void main(String[] args) {
        new Thread(new ImplementRunnable()).start();
        for (int i = 0; i < 2000; i++) {
            System.out.println("MAIN Thread:"+i);
        }
        
    }
}
```

* - new Thread(new ImplementRunnable()).start(); æ–¹æ³•ï¼Œå…¶å®æ˜¯å‘Threadç±»ä¼ é€’ä¸€ä¸ªå‚æ•°ï¼ŒThreadç±»ï¼Œåšäº†ä¸€å±‚ç®€å•çš„é™æ€ä»£ç†ï¼Œå°†new ImplementRunnable()å‚æ•°ä½œä¸ºtargetï¼Œå­˜å…¥Threadç±»çš„æˆå‘˜å±æ€§ä¸­ï¼Œstart0å›è°ƒå›æ¥çš„æ—¶å€™ï¼Œè°ƒç”¨Threadçš„runæ–¹æ³•ï¼ŒThreadåˆ¤æ–­targetä¸ä¸ºç©ºï¼Œè°ƒç”¨targetçš„runæ–¹æ³•ï¼Œæ‰§è¡Œçº¿ç¨‹ä»»åŠ¡ä»£ç 

```java
    /* What will be run. */
    private Runnable target;

public Thread(Runnable target) {
        this(null, target, "Thread-" + nextThreadNum(), 0);
    }

    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
```

* å®ç°Callable
  - éœ€è¦è¿”å›å€¼ç±»å‹
  - éœ€è¦é‡æ–°callæ–¹æ³•ï¼Œéœ€è¦æŠ›å‡ºå¼‚å¸¸
  - åˆ›å»ºç›®æ ‡å¯¹è±¡
  - åˆ›å»ºæ‰§è¡ŒæœåŠ¡
  - æäº¤æ‰§è¡Œ
  - è·å–ç»“æœ
  - å…³é—­æœåŠ¡

```java
public class ThreadCallable implements Callable {
    @Override
    public Boolean call() throws Exception {
        System.out.println("xxx");
        return true;
    }
    public static void main(String[] args)throws Exception {
        //å¼€å¯çº¿ç¨‹æ± 
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        //æäº¤ä»»åŠ¡
        Future submit = executorService.submit(new ThreadCallable());
        //è·å–ä»»åŠ¡æ‰§è¡Œç»“æœ
        submit.get();
        //ä»»åŠ¡å®Œæˆï¼Œå…³é—­çº¿ç¨‹æ± ï¼Œä¸ç„¶çº¿ç¨‹æ± ä¸­ä¼šæœ‰ä¸€ä¸ªé˜»å¡é˜Ÿåˆ—ï¼Œçº¿ç¨‹æ± ä¼šé˜»å¡ï¼Œç­‰å¾…ä»»åŠ¡
        if (submit.isDone()){
            executorService.shutdownNow();
        }
    }
}
```

## é¾Ÿå…”èµ›è·‘æ¨¡æ‹Ÿå¤šçº¿ç¨‹

```java
public class Race implements Runnable{
    private static String WINNER;

    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {
            boolean flag = gameOver(i);
            if (flag){
                break;
            }
            System.out.println(Thread.currentThread().getName()+"è·‘äº†-"+i);
        }
    }
    private boolean gameOver(int i) {
        if (StringUtils.hasLength(WINNER)){
            System.out.println("winner is "+WINNER);
            return true;
        }
        if (i>=100){
            WINNER=Thread.currentThread().getName();
            return true;
        }
        return false;
    }
    /**
     * é¾Ÿå…”èµ›è·‘
     */
    public static void main(String[] args) {
        //è§„å®šåŒä¸€ä¸ªèµ›é“
        Race race = new Race();
        new Thread(race,"å…”å­").start();
        new Thread(race,"ä¹Œé¾Ÿé¬¼").start();
    }
}

```

## çº¿ç¨‹çš„äº”å¤§çŠ¶æ€



![image-20220729161305993](/Users/hhh/Library/Application Support/typora-user-images/image-20220729161305993.png)





![image-20220729163029636](/Users/hhh/Library/Application Support/typora-user-images/image-20220729163029636.png)

### çº¿ç¨‹åœæ­¢

 * ä¸æ¨èä½¿ç”¨JDKæä¾›çš„stopæ–¹æ³•ï¼ŒJDKä¹Ÿå·²ç»å°†stopæ–¹æ³•åºŸå¼ƒ
 * æ¨èçº¿ç¨‹è‡ªå·±åˆ¤æ–­æ‰§è¡Œå®Œæˆååœæ­¢ï¼Œä¾‹å¦‚æœ¬ä¾‹å­ä¸­

```java
public class StopThread implements Runnable {

    private static Boolean FLAG=Boolean.TRUE;

    @Override
    public void run(){
        while (FLAG){
            System.out.println("thread execute");
            //ç»™ä¸ªæ ‡è¯†è®©çº¿ç¨‹è‡ªç„¶åœæ­¢
            FLAG=false;
        }
    }
    /**
     * åœæ­¢çº¿ç¨‹
     * - ä¸æ¨èä½¿ç”¨JDKæä¾›çš„stopæ–¹æ³•ï¼ŒJDKä¹Ÿå·²ç»å°†stopæ–¹æ³•åºŸå¼ƒ
     * - æ¨èçº¿ç¨‹è‡ªå·±åˆ¤æ–­æ‰§è¡Œå®Œæˆååœæ­¢ï¼Œä¾‹å¦‚æœ¬ä¾‹å­ä¸­
     */
    public static void main(String[] args) {
        new Thread(new StopThread()).start();
    }
}
```

### çº¿ç¨‹ä¼‘çœ 

- sleepæ—¶é—´è¾¾åˆ°ä»¥åçº¿ç¨‹è¿›å…¥å°±ç»ªçŠ¶æ€ï¼Œç­‰å¾…CPUè°ƒåº¦æ‰§è¡Œ
- æ¯ä¸ªå¯¹è±¡éƒ½æœ‰ä¸€ä¸ªé”ï¼Œsleepä¸ä¼šé‡Šæ”¾å¯¹è±¡é”

### çº¿ç¨‹ç¤¼è®©

- ç¤¼è®©çº¿ç¨‹ï¼Œå½“å‰æ­£åœ¨æ‰§è¡Œçš„çº¿ç¨‹æš‚åœï¼Œä½†ä¸é˜»å¡
- å°†çº¿ç¨‹ä»è¿è¡ŒçŠ¶æ€è½¬ä¸ºå°±ç»ªçŠ¶æ€
- è®©CPUé‡æ–°è°ƒåº¦ï¼Œç¤¼è®©ä¸ä¸€å®šæˆåŠŸï¼Œè¦çœ‹CPUå¿ƒæƒ…

### çº¿ç¨‹å¼ºåˆ¶join

- joinä½•å¿…çº¿ç¨‹ï¼Œå¾…æ­¤çº¿ç¨‹æ‰§è¡Œå®Œæˆåï¼Œæ‰§è¡Œå…¶ä»–çº¿ç¨‹ï¼Œå…¶ä»–çº¿ç¨‹é˜»å¡
- å¯ä»¥æƒ³è±¡ä¸ºæ’é˜Ÿ

### è§‚æµ‹çº¿ç¨‹çŠ¶æ€

å¯ä»¥é€šè¿‡thread.getState()è·å–çº¿ç¨‹çŠ¶æ€

```java
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```

```java
public static void main(String[] args) {
    Thread thread = new Thread(new SleepThread());
    thread.start();
    Thread.State state = thread.getState();
}
```

### çº¿ç¨‹ä¼˜å…ˆçº§

çº¿ç¨‹ä¼˜å…ˆçº§è¶Šé«˜ï¼Œå¹¶ä¸ä»£è¡¨ä¸€å®šä¼šæœ€ä¼˜å…ˆæ‰§è¡Œï¼Œè¿˜æ˜¯éœ€è¦è®©CPUè¿›è¡Œè°ƒåº¦ï¼Œä½†æ˜¯ä¼˜å…ˆçº§è¶Šé«˜ä»£è¡¨ä¼˜å…ˆæ‰§è¡Œçš„æƒé‡è¶Šé«˜

```java
    /**
     * The minimum priority that a thread can have.
     */
    public static final int MIN_PRIORITY = 1;

    /**
     * The default priority that is assigned to a thread.
     */
    public static final int NORM_PRIORITY = 5;

    /**
     * The maximum priority that a thread can have.
     */
    public static final int MAX_PRIORITY = 10;
```

## FutureTask

### Future

```java
public interface Future<V> {

    /**
     * å–æ¶ˆ
     */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
     * æ˜¯å¦å–æ¶ˆ
     */
    boolean isCancelled();

    /**
     * æ˜¯å¦å®Œæˆ
     */
    boolean isDone();
    /**
     * è·å–æ‰§è¡Œç»“æœ
     */
    V get() throws InterruptedException, ExecutionException;
    /**
     * å¸¦è¶…æ—¶æ“ä½œçš„è·å–æ‰§è¡Œç»“æœ
     */
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

### RunnableFuture

- ç»§æ‰¿äº†Runnableï¼Œè¯´æ˜å…¶é‡å†™äº†runæ–¹æ³•ï¼Œå°†è¿™ä¸ªä»»åŠ¡æäº¤åˆ°çº¿ç¨‹æ± ï¼Œçº¿ç¨‹æ± è°ƒåº¦æ‰§è¡Œï¼Œè°ƒç”¨start0ï¼Œä¼šè°ƒç”¨å›æœ¬ç±»çš„runæ–¹æ³•ï¼Œæ‰§è¡Œæˆ‘ä»¬è‡ªå·±çš„çº¿ç¨‹é€»è¾‘

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```

### FutureTask

- å®ç°RunnableFutureï¼Œæ—¢èƒ½runï¼Œåˆèƒ½è·å–çº¿ç¨‹æœªæ¥æ‰§è¡Œç»“æœ
- ç›¸å½“äºåœ¨çº¿ç¨‹å¤–ï¼ŒåˆåŒ…äº†ä¸€å±‚ï¼Œç”¨äºæ‰§è¡ŒFutureTaskçš„runæ–¹æ³•çš„é€»è¾‘ï¼Œrunæ–¹æ³•
  - ä¾‹å¦‚ï¼Œè°ƒç”¨get()ï¼Œæ˜¯æˆ‘ä»¬çš„ä¸»çº¿ç¨‹åœ¨è°ƒç”¨getï¼Œè¿›å…¥getæ–¹æ³•çš„è‡ªæ—‹ï¼Œä¸»çº¿ç¨‹ä¼šè¢«parkï¼Œç­‰å¾…FutureTask çš„runæ–¹æ³•ï¼Œæ‰§è¡Œå®Œæˆï¼Œè°ƒç”¨finishCompletion()ï¼Œå°†è¿”å›å€¼æ”¾å…¥outcomeï¼Œunparkå”¤é†’ä¸»çº¿ç¨‹ï¼Œä¸»çº¿ç¨‹æ‹¿åˆ°ç»“æœï¼Œè¿”å›ç»™ç”¨æˆ·

```java
public class FutureTask<V> implements RunnableFuture<V> {
    /**
     * å½“å‰ä»»åŠ¡çŠ¶æ€
     */
    private volatile int state;
    private static final int NEW          = 0;//å½“å‰ä»»åŠ¡å°šæœªæ‰§è¡Œ
    private static final int COMPLETING   = 1;//å½“å‰ä»»åŠ¡å°šæœªå®Œå…¨ç»“æŸï¼Œä¸€ç§ä¸´ç•ŒçŠ¶æ€
    private static final int NORMAL       = 2;//å½“å‰ä»»åŠ¡æ­£å¸¸ç»“æŸ
    private static final int EXCEPTIONAL  = 3;//å½“å‰ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿäº†å¼‚å¸¸ï¼Œå†…éƒ¨å°è£…çš„callable.runå‘ä¸ŠæŠ›å‡ºå¼‚å¸¸äº†
    private static final int CANCELLED    = 4;//å½“å‰ä»»åŠ¡è¢«å–æ¶ˆï¼Œå½“ä»»åŠ¡æäº¤åˆ°çº¿ç¨‹æ± ä¸€ç›´æœªè¿›è¡Œæ‰§è¡Œï¼Œå¯ä»¥ä½¿ç”¨cancelledå°†ä»»åŠ¡å–æ¶ˆ
    private static final int INTERRUPTING = 5;//å½“å‰ä»»åŠ¡æ­£åœ¨ä¸­æ–­
    private static final int INTERRUPTED  = 6;//å½“å‰ä»»åŠ¡å·²ä¸­æ–­
  
    /** ä½¿ç”¨è£…é¥°è€…æ¨¡å¼ä¼ªè£…æˆcallableæ¥å£ */
    private Callable<V> callable;
    /**
     * æ­£å¸¸æƒ…å†µä¸‹ï¼Œä»»åŠ¡æ­£å¸¸æ‰§è¡Œç»“æŸï¼Œoutcomeä¿å­˜æ‰§è¡Œç»“æœï¼Œå°±æ˜¯callableçš„è¿”å›å€¼
     * éæ­£å¸¸æƒ…å†µï¼Œcallableå‘ä¸ŠæŠ›å‡ºå¼‚å¸¸ï¼Œoutcomeä¿å­˜å¼‚å¸¸
     */    
    private Object outcome; 
    //å½“å‰ä»»åŠ¡è¢«çº¿ç¨‹æ‰§è¡ŒæœŸé—´ï¼Œä¿å­˜å½“å‰æ‰§è¡Œä»»åŠ¡çº¿ç¨‹å¯¹è±¡çš„å¼•ç”¨
    private volatile Thread runner;  
    //å› ä¸ºä¼šæœ‰å¾ˆå¤šçº¿ç¨‹ä¼šå»getå½“å‰ä»»åŠ¡çš„ç»“æœï¼Œæ‰€ä»¥è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ªæ ˆ
    private volatile WaitNode waiters;  
    /**
     * Callableåˆ›å»ºFutureTask
     */    
    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        //ç¨‹åºå‘˜è‡ªå·±ä¼ å…¥çš„callableå¯¹è±¡ï¼Œcallableçš„è¿”å›å€¼å¯èƒ½æ˜¯ä¸€ä¸ªæœ‰å€¼ä¹Ÿæœ‰å¯èƒ½ä¸ºnullï¼Œä¸ºnullï¼Œæ˜¯å› ä¸ºåœ¨submitçš„æ—¶å€™ï¼Œä¼ å…¥äº†ä¸€ä¸ªRunnableï¼Œé»˜è®¤è¿”å›å€¼ä¸ºnull
        this.callable = callable;
        this.state = NEW;//è®¾ç½®å½“å‰ä»»åŠ¡çŠ¶æ€ä¸ºnew
    }

    /**
     * Runnableåˆ›å»ºFutureTask
     */
    public FutureTask(Runnable runnable, V result) {
        //å°†runnableï¼Œé€šè¿‡é€‚é…å™¨å°è£…ä¸ºäº†callableï¼Œä¼ å…¥çš„ç»“æœä¼šåœ¨çº¿ç¨‹æ‰§è¡Œå®Œæˆåï¼Œè¿”å›ï¼Œä¼ å…¥ä»€ä¹ˆè¿”å›ä»€ä¹ˆ
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // è®¾ç½®æ‰§è¡ŒçŠ¶æ€ä¸ºnew
    }  
  
    private static final class RunnableAdapter<T> implements Callable<T> {
        private final Runnable task;
        private final T result;
        RunnableAdapter(Runnable task, T result) {
            this.task = task;
            this.result = result;
        }
        public T call() {
            task.run();//è¿è¡Œä»»åŠ¡
            return result;//å°†ä¼ å…¥çš„å€¼åœ¨è¿”å›å›å»ï¼Œå¹¶æ²¡æœ‰ä½¿ç”¨çº¿ç¨‹æ‰§è¡Œä»»åŠ¡çš„ç»“æœè¿”å›
        }
        public String toString() {
            return super.toString() + "[Wrapped task = " + task + "]";
        }
    }  

}
```

#### run()

```java
    public void run() {
      //state != NEW ä»£è¡¨ä»»åŠ¡å·²ç»è¢«æ‰§è¡Œè¿‡äº†ï¼Œæˆ–è€…è¢«canceläº†ï¼Œæ€»ä¹‹énewçŠ¶æ€çš„ä»»åŠ¡çº¿ç¨‹å°±ä¸å¤„ç†äº†ï¼Œç›´æ¥è¿”å›
      //!RUNNER.compareAndSet(this, null, Thread.currentThread()) falseä»£è¡¨çº¿ç¨‹æŠ¢å å¤±è´¥ï¼Œä¼šè¿”å›
        if (state != NEW ||
            !RUNNER.compareAndSet(this, null, Thread.currentThread()))
            return;
        try {
            //æ‰§è¡Œåˆ°è¿™é‡Œï¼Œå½“å‰taskä¸€å®šæ˜¯newï¼Œä¸”æŠ¢å çº¿ç¨‹æˆåŠŸï¼Œè¿™ä¸ªcallableå°±æ˜¯ç¨‹åºå‘˜è‡ªå·±å°è£…é€»è¾‘çš„callable/runable
            Callable<V> c = callable;
            //c != nullåˆ¤æ–­ä»»åŠ¡ä¸ä¸ºç©ºï¼Œé˜²æ­¢ç¨‹åºå‘˜ä¼ äº†ä¸€ä¸ªnullï¼Œä¸”çº¿ç¨‹ä¸ºnewï¼Œé˜²æ­¢å¤–éƒ¨çº¿ç¨‹cancelæ‰è¿™ä¸ªçº¿ç¨‹
            if (c != null && state == NEW) {
              //çº¿ç¨‹æ‰§è¡Œç»“æœå¼•ç”¨
                V result;
              //trueè¡¨ç¤ºcallable.runä»£ç æ‰§è¡ŒæˆåŠŸï¼Œä»£ç æ²¡æœ‰å¼‚å¸¸ï¼Œfalseä»£è¡¨ç¨‹åºå‘˜ä»£ç æŠ›å‡ºå¼‚å¸¸
                boolean ran;
                try {
                  //è°ƒç”¨ç¨‹åºå‘˜è‡ªå·±å°è£…çš„ä»£ç 
                    result = c.call();
                  //æ­£å¸¸æ‰§è¡Œï¼ŒæœªæŠ›å‡ºä»»ä½•å¼‚å¸¸ï¼Œrunè®¾ç½®ä¸ºtrue
                    ran = true;
                } catch (Throwable ex) {
                  //è®¾ç½®è¿”å›å€¼ä¸ºnull
                    result = null;
                  //æ‰§è¡Œå¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸ï¼Œrunè®¾ç½®ä¸ºfalse
                    ran = false;
                  //å°†å¼‚å¸¸è®¾ç½®åˆ°outcomeä¸­ï¼Œå°†çŠ¶æ€ä¿®æ”¹ä¸ºCOMPLETINGï¼Œoutcomeå¼•ç”¨çš„æ˜¯ï¼Œcallableå‘ä¸ŠæŠ›å‡ºçš„å¼‚å¸¸ï¼Œå°†ä»»åŠ¡çŠ¶æ€è®¾ç½®ä¸ºEXCEPTIONAL
                    setException(ex);
                }
                if (ran)
                  //è¯´æ˜å½“å‰c.callæ­£å¸¸æ‰§è¡Œï¼Œè®¾ç½®ç»“æœå€¼åˆ°outcomeï¼Œè®¾ç½®ä»»åŠ¡çŠ¶æ€ä¸ºCOMPLETINGæˆåŠŸä¹‹åï¼Œå°±ä¼šå°†çº¿ç¨‹ä»»åŠ¡è®¾ç½®ä¸ºNORMALçŠ¶æ€ï¼Œçº¿ç¨‹æ­£å¸¸ç»“æŸï¼Œä¼šè°ƒç”¨finishCompletion()ï¼Œé€šçŸ¥parkçš„çº¿ç¨‹é‡æ–°å¯åŠ¨
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
          //åˆ¤æ–­çº¿ç¨‹æ˜¯å¦ä¸ºä¸­æ–­ä¸­
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }  
  
```

#### get()ä¸awaitDoneå…¥é˜Ÿ

```java
		//è®°å¾—æ€è€ƒåœºæ™¯ï¼Œå¤šä¸ªçº¿ç¨‹åŒæ—¶è·å–ï¼Œç­‰å¾…è¿™ä¸ªçº¿ç¨‹ä»»åŠ¡æ‰§è¡Œç»“æœ
		public V get() throws InterruptedException, ExecutionException {
      //è·å–å½“å‰ä»»åŠ¡çŠ¶æ€
        int s = state;
      //å°äºCOMPLETINGçŠ¶æ€ï¼Œæœªæ‰§è¡Œ/æ­£åœ¨æ‰§è¡Œ/æ­£åœ¨å®Œæˆ/ï¼Œè°ƒç”¨getçš„å¤–éƒ¨çº¿ç¨‹ä¼šè¢«é˜»å¡åœ¨getæ–¹æ³•ä¸Šï¼Œé‚£ä¹ˆæ€ä¹ˆå®ç°é˜»å¡å‘¢ï¼Ÿ
        if (s <= COMPLETING)
          //è¿”å›taskå½“å‰çŠ¶æ€ï¼Œå¯èƒ½å½“å‰çº¿ç¨‹å·²ç»åœ¨é‡Œé¢parkè¿‡ä¸€ä¼šäº†
            s = awaitDone(false, 0L);
      //å‘å¤–æŠ¥å‘Šç»“æœ
        return report(s);
    }


		//timedå±æ€§ä¸ºå¸¦ä¸å¸¦è¶…æ—¶ï¼ŒWaitNodeå…¥é˜Ÿ
    private int awaitDone(boolean timed, long nanos)
        throws InterruptedException {
        long startTime = 0L;
      //å¼•ç”¨å½“å‰çº¿ç¨‹ï¼Œå°è£…æˆWaitNodeå¯¹è±¡
        WaitNode q = null;
      //è¡¨ç¤ºå½“å‰WaitNodeå¯¹è±¡æœ‰æ²¡æœ‰å‹æ ˆ
        boolean queued = false;
        for (;;) {
          //åœ¨æœ€åä¸€æ­¥elseï¼Œçº¿ç¨‹ä¼šè¢«parkï¼Œå¦‚æœè¢«å”¤é†’ï¼Œçº¿ç¨‹ä¼šå†æ¬¡è¿›å…¥è‡ªæ—‹ï¼Œ
          //çº¿ç¨‹æ˜¯è¢«å…¶ä»–çº¿ç¨‹ä½¿ç”¨un parkçº¿ç¨‹å”¤é†’ï¼Œä»£ç ä¼šæ­£å¸¸æ‰§è¡Œ
            int s = state;
          //s > COMPLETINGè¯´æ˜å½“å‰ä»»åŠ¡å·²ç»æœ‰ç»“æœäº†ï¼Œå¯èƒ½æ˜¯å¥½ï¼Œä¹Ÿå¯èƒ½æ˜¯å
            if (s > COMPLETING) {
              //æ¡ä»¶æˆç«‹è¯´æ˜å½“å‰çº¿ç¨‹å·²ç»åˆ›å»ºè¿‡nodeäº†ï¼Œæ­¤æ—¶éœ€è¦å°†nod.thread=null
                if (q != null)
                    q.thread = null;
              //æ‰§è¡Œè¿”å›å½“å‰çŠ¶æ€
                return s;
            }
          //è¡¨ç¤ºå½“å‰è¿™ä¸ªä»»åŠ¡å¿«å®Œæˆäº†ï¼Œè®©å½“å‰çº¿ç¨‹é‡Šæ”¾CPUï¼Œè¿›è¡Œä¸‹ä¸€æ¬¡æŠ¢å CPU
            else if (s == COMPLETING)
                //é‡Šæ”¾CPUè¿è¡Œæƒé™ï¼Œè¿›å…¥ä¸‹ä¸€æ¬¡äº‰æŠ¢CPU
                Thread.yield();
          //Thread.interrupted()æ¡ä»¶æˆç«‹ï¼Œè¯´æ˜å½“å‰çº¿ç¨‹æ˜¯è¢«å…¶ä»–çº¿ç¨‹ä½¿ç”¨ä¸­æ–­å”¤é†’çš„ï¼Œéœ€è¦æŠ›å‡ºInterruptedExceptionå¼‚å¸¸
            else if (Thread.interrupted()) {
              //å°†å½“å‰nodeèŠ‚ç‚¹ä»é˜»å¡é˜Ÿåˆ—è¿›è¡Œå‡ºé˜Ÿ
                removeWaiter(q);
              //å‘getæ–¹æ³•æŠ›å‡ºä¸­æ–­å¼‚å¸¸
                throw new InterruptedException();
            }
          //1.è¡¨ç¤ºç¬¬ä¸€æ¬¡è‡ªæ—‹ï¼Œå½“å‰çº¿ç¨‹è¿˜æœªåˆ›å»ºWaitNodeå¯¹è±¡ï¼Œä¸ºå½“å‰çº¿ç¨‹åˆ›å»ºWaitNodeå¯¹è±¡
            else if (q == null) {
                if (timed && nanos <= 0L)
                    return s;
                q = new WaitNode();
            }
          //ç¬¬äºŒæ¬¡è‡ªæ—‹ï¼Œå½“å‰çº¿ç¨‹åˆ›å»ºäº†WaitNodeå¯¹è±¡ï¼Œä½†æ˜¯è¿˜æ²¡å…¥é˜Ÿï¼Œéœ€è¦åšå…¥é˜Ÿç›¸å…³æ“ä½œ
            else if (!queued)
              //å°†å½“å‰çº¿ç¨‹WaitNodeèŠ‚ç‚¹nextæŒ‡å‘é˜Ÿåˆ—çš„å¤´èŠ‚ç‚¹ï¼Œwaitersä¸€ç›´æŒ‡å‘é˜Ÿåˆ—çš„å¤´ï¼Œä¿®æ”¹å¤´æŒ‡é’ˆæŒ‡å‘èŠ‚ç‚¹
                q.next = waiters;
          		//casæ–¹å¼è®¾ç½®waiterså¼•ç”¨æŒ‡å‘å½“å‰çº¿ç¨‹nodeï¼ŒæˆåŠŸçš„è¯queued=trueï¼Œfalseçš„è¯å¯èƒ½æ˜¯å…¶ä»–çº¿ç¨‹å…ˆä¸€æ­¥å…¥é˜Ÿäº†ï¼Œéœ€è¦å†æ¬¡è‡ªæ—‹å°è¯•ï¼ŒçŸ¥é“å…¥é˜ŸæˆåŠŸä¸ºæ­¢
                queued = WAITERS.weakCompareAndSet(this,waiters , q);
          //ç¬¬ä¸‰æ¬¡è‡ªæ—‹ä¼šæ¥åˆ°è¿™é‡Œï¼Œå¦‚æœæˆ‘ä»¬ä¸éœ€è¦è¶…æ—¶æ—¶é—´è·å–ï¼Œä¼šè¿›å…¥ä¸‹é¢çš„else
            else if (timed) {
                final long parkNanos;
                if (startTime == 0L) { // first time
                    startTime = System.nanoTime();
                    if (startTime == 0L)
                        startTime = 1L;
                    parkNanos = nanos;
                } else {
                    long elapsed = System.nanoTime() - startTime;
                    if (elapsed >= nanos) {
                        removeWaiter(q);
                        return state;
                    }
                    parkNanos = nanos - elapsed;
                }
                // nanoTime may be slow; recheck before parking
                if (state < COMPLETING)
                  //
                    LockSupport.parkNanos(this, parkNanos);
            }
            else
              //å½“å‰getæ“ä½œçš„çº¿ç¨‹ï¼Œå°±ä¼šè¢«parkï¼Œçº¿ç¨‹çŠ¶æ€ä¼šå˜ä¸ºwaitingçŠ¶æ€ï¼Œç›¸å½“äºä¼‘çœ äº†ï¼Œé™¤éæœ‰å…¶ä»–çº¿ç¨‹å°†å…¶å”¤é†’æˆ–è€…å°†å…¶ä¸­æ–­
                LockSupport.park(this);
        }
    }

```



#### removeWaiter()å‡ºé˜Ÿ

```java
private void removeWaiter(WaitNode node) {
    if (node != null) {
        node.thread = null;
        retry:
        for (;;) {          // restart on removeWaiter race
            for (WaitNode pred = null, q = waiters, s; q != null; q = s) {
                s = q.next;
                if (q.thread != null)
                    pred = q;
                else if (pred != null) {
                    pred.next = s;
                    if (pred.thread == null) // check for race
                        continue retry;
                }
                else if (!WAITERS.compareAndSet(this, q, s))
                    continue retry;
            }
            break;
        }
    }
}
```



#### report

```java
    private V report(int s) throws ExecutionException {
      //æ­£å¸¸outcomeå­˜çš„æ˜¯çº¿ç¨‹ä»»åŠ¡çš„æ‰§è¡Œç»“æœï¼Œå¼‚å¸¸çš„è¯ï¼Œoutcomeå­˜çš„æ˜¯çº¿ç¨‹æ‰§è¡Œçš„å¼‚å¸¸
        Object x = outcome;
      //åˆ¤æ–­çº¿ç¨‹çŠ¶æ€ï¼Œæ­£å¸¸çš„è¯ï¼Œç›´æ¥è¿”å›çº¿ç¨‹æ‰§è¡Œç»“æœ
        if (s == NORMAL)
            return (V)x;
      //å¤§äºç­‰äºCANCELLEDï¼Œå°±æ˜¯è¢«å–æ¶ˆçŠ¶æ€ï¼Œç›´æ¥æŠ›å‡ºçŠ¶æ€
        if (s >= CANCELLED)
            throw new CancellationException();
      //è¯´æ˜callableä»£ç å®ç°ä¸­ï¼Œä»»åŠ¡æ‰§è¡ŒæŠ›å‡ºå¼‚å¸¸
        throw new ExecutionException((Throwable)x);
    }



```

#### finishCompletion

```java
    private void finishCompletion() {
      //qæŒ‡å‘WaitNodeé“¾è¡¨å¤´èŠ‚ç‚¹
        for (WaitNode q; (q = waiters) != null;) {
          //ä½¿ç”¨CASè®¾ç½®WAITERSä¸ºnullï¼Œæ€•å¤–éƒ¨çº¿ç¨‹ä½¿ç”¨cancelæ–¹æ³•
            if (WAITERS.weakCompareAndSet(this, q, null)) {
                for (;;) {
                  //è·å–å½“å‰WaitNodeèŠ‚ç‚¹å°è£…çš„threadèŠ‚ç‚¹
                    Thread t = q.thread;
                    if (t != null) {
                      //å½“å‰çº¿ç¨‹ä¸ä¸ºç©ºï¼Œå°†èŠ‚ç‚¹çº¿ç¨‹è®¾ç½®ä¸ºnull
                        q.thread = null;
                      //å”¤é†’å½“å‰çº¿ç¨‹
                        LockSupport.unpark(t);
                    }
                  //å¤„ç†å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                    WaitNode next = q.next;
                  //ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å¦‚æœä¸ºç©ºï¼Œä»£è¡¨å½“å‰å¤„ç†ä¸ºæœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›´æ¥é€€å‡ºï¼Œå¦åˆ™ç»§ç»­å¾ªç¯å¤„ç†èŠ‚ç‚¹
                    if (next == null)
                        break;
                    q.next = null; // unlink to help gc
                    q = next;
                }
                break;
            }
        }

        done();
      //å°†callableè®¾ç½®ä¸ºç©º
        callable = null;        // to reduce footprint
    }
```

#### cancel

```java

public boolean cancel(boolean mayInterruptIfRunning) {
  //state == NEWä¸”å½“å‰ä»»åŠ¡å¤„äºè¿è¡Œä¸­æˆ–è€…çº¿ç¨‹æ± é˜Ÿåˆ—ä¸­
    if (!(state == NEW && STATE.compareAndSet
          (this, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))
        return false;
    try {    
      //æ˜¯å¦éœ€è¦ç»™å½“å‰æ­£åœ¨æ‰§è¡Œçš„çº¿ç¨‹å‘é€ä¸€ä¸ªä¸­æ–­ä¿¡å·
        if (mayInterruptIfRunning) {
            try {
                Thread t = runner;
              //æ˜¯nullçš„æ—¶å€™ï¼Œçº¿ç¨‹è¿˜åœ¨ä»»åŠ¡é˜Ÿåˆ—ä¸­ï¼Œè¿˜æ²¡æœ‰è¢«çº¿ç¨‹è·å–åˆ°
                if (t != null)
                  //tä¸ä¸ºç©ºï¼Œæœ‰çº¿ç¨‹æ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼Œç»™çº¿ç¨‹ä¸€ä¸ªä¸­æ–­ä¿¡å·
                    t.interrupt();
            } finally {
              //è®¾ç½®ä»»åŠ¡çŠ¶æ€ä¸ºä¸­æ–­å®Œæˆ
                STATE.setRelease(this, INTERRUPTED);
            }
        }
    } finally {
      //å°†çº¿ç¨‹å”¤é†’ï¼Œå”¤é†’æ‰€æœ‰geté˜»å¡çº¿ç¨‹
        finishCompletion();
    }
    return true;
}
```

## çº¿ç¨‹æ± 

### ä½¿ç”¨Java Executorså·¥å…·åˆ›å»ºçº¿ç¨‹æ± 

ä½¿ç”¨Java Executorså·¥å…·åˆ›å»ºçº¿ç¨‹æ± ï¼Œæ— æ³•æŒ‡å®šçº¿ç¨‹æ± çš„æ ¸å¿ƒå‚æ•°ï¼Œæ— æ³•å¯¹çº¿ç¨‹æ± è¿›è¡Œæ›´å¥½çš„æ§åˆ¶

```java
public class Test {
    public static void main(String[] args) {
        //åªèƒ½é…ç½®æ ¸å¿ƒçº¿ç¨‹æ•°
        ExecutorService executorService = Executors.newFixedThreadPool(1);
    }
}
```

### ThreadPoolExecutor

Javaä¸­ä½¿ç”¨çš„çº¿ç¨‹æ± ä¸ºThreadPoolExecutorï¼Œæˆ‘ä»¬å¸¸è¯´çš„çº¿ç¨‹æ± 7å¤§æ ¸å¿ƒå‚æ•°ï¼Œå…¶å®å°±æ˜¯ThreadPoolExecutorç±»çš„æ„é€ æ–¹æ³•

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
    }
```

- corePoolSizeï¼šæ ¸å¿ƒçº¿ç¨‹æ•°
- maximumPoolSizeï¼šæœ€å¤§çº¿ç¨‹æ•°
- keepAliveTimeï¼šçº¿ç¨‹ç©ºé—²æ—¶é—´
- TimeUnitï¼šçº¿ç¨‹ç©ºé—²æ—¶é—´å•ä½
- workQueueï¼šé˜»å¡é˜Ÿåˆ—ï¼Œç»†ç²’åº¦æ§åˆ¶çº¿ç¨‹ï¼Œå¯ä»¥åœ¨å¦‚ä¸‹4ä¸ªä¸­é€‰æ‹©ä½¿ç”¨çš„çº¿ç¨‹é˜Ÿåˆ—
  - ArrayBlockingQueueï¼šæ— åº
  - LinkedBlockingQueueï¼šæœ‰åº
  - PriorityBlockingQueueï¼šä¼˜å…ˆçº§
  - SynchronousQueueï¼šé˜»å¡

- threadFactoryï¼šçº¿ç¨‹å·¥å‚ï¼Œå¯ä»¥æŒ‡å®šçº¿ç¨‹åç§°ï¼Œåç»­ä¾‹å¦‚å‡ºç°é¢‘ç¹GCï¼Œå°±å¯ä»¥é€šè¿‡çº¿ç¨‹åç§°å®šä½å‡ºç°é—®é¢˜çš„çº¿ç¨‹
- handlerï¼šæ‹’ç»ç­–ç•¥
  - AbortPolicy
  - CallerRunsPolicy
  - DiscardOldestPolicy
  - DiscardPolicy

### çº¿ç¨‹æ± æ ¸å¿ƒå‚æ•°å¦‚ä½•åˆç†è®¾ç½®ï¼Ÿ

#### corePoolSize

- æ ¸å¿ƒçº¿ç¨‹ä¼šä¸€ç›´å­˜æ´»ï¼Œå³ä½¿æ²¡æœ‰ä»»åŠ¡éœ€è¦æ‰§è¡Œã€‚
- å½“çº¿ç¨‹æ•°å°äºæ ¸å¿ƒçº¿ç¨‹æ•°æ—¶ï¼Œå³ä½¿æœ‰çº¿ç¨‹ç©ºé—²ï¼Œçº¿ç¨‹æ± ä¹Ÿä¼šä¼˜å…ˆåˆ›å»ºæ–°çº¿ç¨‹å¤„ç†ã€‚
- è®¾ç½®allowCoreThreadTimeout=trueï¼ˆé»˜è®¤falseï¼‰æ—¶ï¼Œæ ¸å¿ƒçº¿ç¨‹ä¼šè¶…æ—¶å…³é—­ã€‚

å¦‚ä½•è®¾ç½®å¥½çš„å‰ææˆ‘ä»¬è¦å¾ˆæ¸…æ¥šçš„çŸ¥é“`CPUå¯†é›†å‹`å’Œ`IOå¯†é›†å‹`çš„åŒºåˆ«

##### CUPå¯†é›†å‹

`CPUå¯†é›†å‹`ä¹Ÿå«`è®¡ç®—å¯†é›†å‹`ï¼ŒæŒ‡çš„æ˜¯ç³»ç»Ÿçš„ç¡¬ç›˜ã€å†…å­˜æ€§èƒ½ç›¸å¯¹CPUè¦å¥½å¾ˆå¤šï¼Œæ­¤æ—¶ï¼Œç³»ç»Ÿè¿ä½œå¤§éƒ¨åˆ†çš„çŠ¶å†µæ˜¯CPU Loading 100%ï¼ŒCPUè¦è¯»/å†™I/O(ç¡¬ç›˜/å†…å­˜)ï¼ŒI/Oåœ¨å¾ˆçŸ­çš„æ—¶é—´å°±å¯ä»¥å®Œæˆï¼Œè€ŒCPUè¿˜æœ‰è®¸å¤šè¿ç®—è¦å¤„ç†ï¼Œ**CPU Loading å¾ˆé«˜ï¼Œç¨‹åºè¿è¡Œçš„å¤§éƒ¨åˆ†æ—¶é—´æ˜¯CPUè¿ç®—**

##### IOå¯†é›†å‹

IOå¯†é›†å‹æŒ‡çš„æ˜¯ç³»ç»Ÿçš„CPUæ€§èƒ½ç›¸å¯¹ç¡¬ç›˜ã€å†…å­˜è¦å¥½å¾ˆå¤šï¼Œæ­¤æ—¶ï¼Œç³»ç»Ÿè¿ä½œï¼Œ**å¤§éƒ¨åˆ†çš„çŠ¶å†µæ˜¯CPUåœ¨ç­‰I/O (ç¡¬ç›˜/å†…å­˜) çš„è¯»/å†™æ“ä½œï¼Œæ­¤æ—¶CPU Loadingå¹¶ä¸é«˜ã€‚I/O boundçš„ç¨‹åºä¸€èˆ¬åœ¨è¾¾åˆ°æ€§èƒ½æé™æ—¶ï¼ŒCPUå ç”¨ç‡ä»ç„¶è¾ƒä½**ã€‚

##### æœºå™¨æ ¸æ•°

```java
System.out.println(Runtime.getRuntime().availableProcessors());
```

##### è®¡ç®—å…¬å¼

- CPUå¯†é›†å‹ï¼šcorePoolSize = CPUæ ¸æ•° + 1

- IOå¯†é›†å‹ï¼šcorePoolSize = CPUæ ¸æ•° \* 2

#### maximumPoolSize

éœ€è¦è®¾ç½®æœ€å¤§çº¿ç¨‹æ•°ğŸŸ°æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œé¿å…CPUé¢‘ç¹çš„è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢

- å½“çº¿ç¨‹æ•°>=corePoolSizeï¼Œä¸”ä»»åŠ¡é˜Ÿåˆ—å·²æ»¡æ—¶ã€‚çº¿ç¨‹æ± ä¼šåˆ›å»ºæ–°çº¿ç¨‹æ¥å¤„ç†ä»»åŠ¡ã€‚
- å½“çº¿ç¨‹æ•°=maxPoolSizeï¼Œä¸”ä»»åŠ¡é˜Ÿåˆ—å·²æ»¡æ—¶ï¼Œçº¿ç¨‹æ± ä¼šæ‹’ç»å¤„ç†ä»»åŠ¡è€ŒæŠ›å‡ºå¼‚å¸¸ã€‚

#### keepAliveTime

- å½“çº¿ç¨‹ç©ºé—²æ—¶é—´è¾¾åˆ°keepAliveTimeæ—¶ï¼Œçº¿ç¨‹ä¼šé€€å‡ºï¼Œç›´åˆ°çº¿ç¨‹æ•°é‡=corePoolSizeã€‚
- å¦‚æœallowCoreThreadTimeout=trueï¼Œåˆ™ä¼šç›´åˆ°çº¿ç¨‹æ•°é‡=0ã€‚

#### workQueue

- å½“æ ¸å¿ƒçº¿ç¨‹æ•°è¾¾åˆ°æœ€å¤§æ—¶ï¼Œæ–°ä»»åŠ¡ä¼šæ”¾åœ¨é˜Ÿåˆ—ä¸­æ’é˜Ÿç­‰å¾…æ‰§è¡Œ

#### RejectedExecutionHandler

ä¸¤ç§æƒ…å†µä¼šæ‹’ç»å¤„ç†ä»»åŠ¡ï¼š

- å½“çº¿ç¨‹æ•°å·²ç»è¾¾åˆ°maxPoolSizeï¼Œä¸”é˜Ÿåˆ—å·²æ»¡ï¼Œä¼šæ‹’ç»æ–°ä»»åŠ¡ã€‚
- å½“çº¿ç¨‹æ± è¢«è°ƒç”¨shutdown()åï¼Œä¼šç­‰å¾…çº¿ç¨‹æ± é‡Œçš„ä»»åŠ¡æ‰§è¡Œå®Œæ¯•å†shutdownã€‚å¦‚æœåœ¨è°ƒç”¨shutdown()å’Œçº¿ç¨‹æ± çœŸæ­£shutdownä¹‹é—´æäº¤ä»»åŠ¡ï¼Œä¼šæ‹’ç»æ–°ä»»åŠ¡ã€‚çº¿ç¨‹æ± ä¼šè°ƒç”¨rejectedExecutionHandleræ¥å¤„ç†è¿™ä¸ªä»»åŠ¡ã€‚å¦‚æœæ²¡æœ‰è®¾ç½®é»˜è®¤æ˜¯AbortPolicyï¼Œä¼šæŠ›å‡ºå¼‚å¸¸ã€‚

ThreadPoolExecutor é‡‡ç”¨äº†ç­–ç•¥çš„è®¾è®¡æ¨¡å¼æ¥å¤„ç†æ‹’ç»ä»»åŠ¡çš„å‡ ç§åœºæ™¯ï¼Œè¿™å‡ ç§ç­–ç•¥æ¨¡å¼éƒ½å®ç°äº†RejectedExecutionHandler æ¥å£

- AbortPolicy ï¼šä¸¢å¼ƒä»»åŠ¡ï¼ŒæŠ›è¿è¡Œæ—¶å¼‚å¸¸ï¼Œä¸æŒ‡å®šï¼Œé»˜è®¤ä¸ºAbortPolicyçš„æ‹’ç»ç­–ç•¥
- CallerRunsPolicyï¼šæ‰§è¡Œä»»åŠ¡ã€‚
- DiscardPolicyï¼šå¿½è§†ï¼Œä»€ä¹ˆéƒ½ä¸ä¼šå‘ç”Ÿã€‚
- DiscardOldestPolicyï¼šä»é˜Ÿåˆ—ä¸­è¸¢å‡ºæœ€å…ˆè¿›å…¥é˜Ÿåˆ—ï¼ˆæœ€åä¸€ä¸ªæ‰§è¡Œï¼‰çš„ä»»åŠ¡ã€‚

## çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹

|                        çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹                        |
| :----------------------------------------------------------: |
| ![image-20220726190031962](/Users/hhh/Library/Application Support/typora-user-images/image-20220726190031962.png) |

### ä¾‹å­

æ‹¿é¥­åº—ä¸­ä¸¾ä¾‹å­

- é¥­åº—ï¼šçº¿ç¨‹æ± 
- ä½å­ï¼šçº¿ç¨‹
- äººå¤šå…ˆæ’é˜Ÿï¼šé˜»å¡é˜Ÿåˆ—
- åœ¨ç©ºé—²å¤„åŠ æ¡Œå­ï¼Œå¢åŠ ä½ç½®ï¼Œæ²¡äººå†å›æ”¶ï¼šåˆ›å»ºæœ€å¤§çº¿ç¨‹æ•°ä¸­çš„çº¿ç¨‹
- ç­‰ä½ä½ç½®ä¹Ÿæ»¡äº†ï¼šæ‹’ç»ç­–ç•¥

### çº¿ç¨‹æ± æ ¸å¿ƒå±æ€§

```java
//1.å£°æ˜å½“å‰çº¿ç¨‹æ± çŠ¶æ€ï¼›2.å£°æ˜çº¿ç¨‹æ± çš„çº¿ç¨‹æ•°
//é«˜3ä½ï¼šçº¿ç¨‹çŠ¶æ€ ä½29ä½ï¼šçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹ä¸ªæ•°
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//æŒ‡çš„æ˜¯ä¸€ä¸ªIntegerå 4ä¸ªå­—èŠ‚ï¼Œ32ä½ï¼Œæä¾›è¿™ä¸ªæ–¹ä¾¿åé¢åšä½è¿ç®—
private static final int COUNT_BITS = Integer.SIZE - 3;
//é€šè¿‡è¿ç®—å¾—åˆ°æœ€å¤§çº¿ç¨‹å®¹é‡
//1å·¦ç§»29ä½åå‡ä¸€
//0000 0000 0000 0000 0000 0001	1
//0010 0000 0000 0000 0000 0000	å·¦ç§»29ä½ - 1
//0001 1111 1111 1111 1111 1111  è¿™ä¸ªä»£è¡¨ï¼šé«˜3ä½ï¼šçº¿ç¨‹çŠ¶æ€ ä½29ä½ï¼šçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹ä¸ªæ•°
private static final int COUNT_MASK = (1 << COUNT_BITS) - 1;

// çº¿ç¨‹æ± çš„5ç§çŠ¶æ€ 
//1111 1111 1111 1111 1111 1111 	-1 å·¦ç§» 29ä½
//1110 0000 0000 0000 0000 0000   111ä»£è¡¨RUNNINGï¼Œæ­£å¸¸æ¥æ”¶ä»»åŠ¡
private static final int RUNNING    = -1 << COUNT_BITS;
//000 ä»£è¡¨çº¿ç¨‹æ± ä¸ºSHUTDOWNçŠ¶æ€ï¼Œä¸æ¥å—æ–°ä»»åŠ¡ï¼Œä½†æ˜¯å†…éƒ¨è¿˜ä¼šå¤„ç†é˜»å¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œæ­£å¸¸è¿›è¡Œä¸­çš„ä»»åŠ¡ä¹Ÿä¼šç»§ç»­æ‰§è¡Œ
private static final int SHUTDOWN   =  0 << COUNT_BITS;
//1å¾€å·¦ç§»åŠ¨29ä½ 001 ä¸æ¥å—æ–°ä»»åŠ¡ï¼Œä¸å¤„ç†é˜»å¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œä¸­æ–­è¿›è¡Œä¸­çš„ä»»åŠ¡
private static final int STOP       =  1 << COUNT_BITS;
//2å·¦ç§»åŠ¨29ä½ 010 è¿‡æ¸¡çŠ¶æ€ï¼Œä»£è¡¨çº¿ç¨‹å³å°†å…³é—­
private static final int TIDYING    =  2 << COUNT_BITS;
//3å·¦ç§»åŠ¨29ä½ 011 çº¿ç¨‹æ± çœŸæ­£å…³é—­ è¦æ‰§è¡ŒTERMINATEDæ–¹æ³•
private static final int TERMINATED =  3 << COUNT_BITS;

// å–åï¼Œå¾—åˆ°çº¿ç¨‹æ± çš„çŠ¶æ€
private static int runStateOf(int c)     { return c & ~COUNT_MASK; }
//å¾—åˆ°å½“å‰çº¿ç¨‹æ± çš„çº¿ç¨‹æ•°é‡
private static int workerCountOf(int c)  { return c & COUNT_MASK; }
//ä¸ºåç»­æ›´æ–°çº¿ç¨‹æ•°å€¼åšå‡†å¤‡
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### çº¿ç¨‹æ± çŠ¶æ€å˜åŒ–

![image-20220726211129326](/Users/hhh/Library/Application Support/typora-user-images/image-20220726211129326.png) 



### ThreadPoolExecutorçº¿ç¨‹æ± æºç 

#### execute

```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
      //æ‹¿åˆ°32ä½int
        int c = ctl.get();
      //å·¥ä½œçº¿ç¨‹æ•° < æ ¸å¿ƒçº¿ç¨‹æ•°
        if (workerCountOf(c) < corePoolSize) {
          //è¿›åˆ°ifï¼Œä»£è¡¨å¯ä»¥åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹æ•°
            if (addWorker(command, true))
              //ä½¿ç”¨æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œç›´æ¥è¿”å›
                return;
          //èµ°åˆ°è¿™ï¼Œä»£è¡¨è·å–æ ¸å¿ƒçº¿ç¨‹æ•°å¤±è´¥ï¼Œå¯èƒ½æœ‰å¹¶å‘æ“ä½œï¼Œæœ‰çº¿ç¨‹è·å–å¤±è´¥äº†
            c = ctl.get();
        }
      //åˆ¤æ–­çº¿ç¨‹æ± æ˜¯å¦è¿˜åœ¨RUNNINGï¼Œå°†ä»»åŠ¡æ·»åŠ åˆ°é˜»å¡é˜Ÿåˆ—ä¸­
        if (isRunning(c) && workQueue.offer(command)) {
          //å†æ¬¡è·å–ctlï¼Œé‡æ–°æ£€æŸ¥ï¼Œæ˜¯å¦ä¸ºRUNNINGï¼Œè€ƒè™‘å¹¶å‘é—®é¢˜
            int recheck = ctl.get();
          //ä¸æ˜¯RUNNINGï¼Œç§»é™¤ä»»åŠ¡
            if (! isRunning(recheck) && remove(command))
              //ç›´æ¥æ‰§è¡Œæ‹’ç»ç­–ç•¥
                reject(command);
          //è·å–ç°åœ¨æ­£åœ¨å·¥ä½œçš„çº¿ç¨‹æ± ä¸ªæ•°ï¼Œå¦‚æœçº¿ç¨‹æ± å¤„äºRUNNINGçŠ¶æ€ï¼Œä¸”å·¥ä½œçº¿ç¨‹ä¸º0
            else if (workerCountOf(recheck) == 0)
              //é˜»å¡é˜Ÿåˆ—æœ‰ä»»åŠ¡ï¼Œä½†æ˜¯æ²¡æœ‰å·¥ä½œçº¿ç¨‹ï¼Œè¿™æ—¶å€™å°±éœ€è¦æ·»åŠ ä¸€ä¸ªä»»åŠ¡ä¸ºç©ºçš„å·¥ä½œçº¿ç¨‹å»å¤„ç†é˜»å¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
                addWorker(null, false);
        }
      //åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹å¤„ç†ä»»åŠ¡
        else if (!addWorker(command, false))
          //
            reject(command);
    }
```

#### addWorker

```java
private boolean addWorker(Runnable firstTask, boolean core) {
  //gotoï¼Œå¤šä¸ªforå¾ªç¯çš„é€€å‡ºï¼Œä½¿ç”¨gotoæ˜¯ä¸ºäº†ï¼Œåœ¨ä¸åŠ é”çš„æƒ…å†µä¸‹ä¿è¯çº¿ç¨‹å®‰å…¨
        retry:
  //è¿™è¾¹çš„forå¾ªç¯ï¼Œåªæ˜¯åšäº†å¤§é‡çš„åˆ¤æ–­ï¼Œç»™å·¥ä½œçº¿ç¨‹æ•°æ ‡è¯†â•1ï¼Œæ²¡æœ‰å…¶ä»–æ“ä½œï¼Œä¹‹æ‰€ä»¥å†™çš„è¿™ä¹ˆå¤æ‚ï¼Œæ˜¯ä¸ºäº†åœ¨ä¸åŠ é”çš„æƒ…å†µä¸‹ä¿è¯çº¿ç¨‹å®‰å…¨
  //è·å–32ä½çš„intå€¼ï¼ˆçº¿ç¨‹æ± çŠ¶æ€ï¼‰ï¼Œè¿›å…¥æ­»å¾ªç¯
        for (int c = ctl.get();;) {
            // æ ¡éªŒéè¿è¡Œæ—¶çŠ¶æ€
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP)
                    //ä¼ nullï¼Œå½“å‰æ²¡æœ‰å·¥ä½œçº¿ç¨‹ï¼Œéœ€è¦åˆ›å»ºä¸€ä¸ªç©ºä»»åŠ¡
                    //firstTask == nullé˜»å¡é˜Ÿåˆ—æœ‰ä»»åŠ¡ï¼Œä½†æ˜¯æ²¡æœ‰å·¥ä½œçº¿ç¨‹ï¼Œè¿™æ—¶å€™å°±éœ€è¦æ·»åŠ ä¸€ä¸ªä»»åŠ¡ä¸ºç©ºçš„å·¥ä½œçº¿ç¨‹å»å¤„ç†é˜»å¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
                    || firstTask != null
                    //é˜»å¡é˜Ÿåˆ—ä¸ºç©º
                    || workQueue.isEmpty()))
              //æ„å»ºå·¥ä½œçº¿ç¨‹å¤±è´¥ï¼Œç›´æ¥é€€å‡º
                return false;
//å‰é¢æ ¡éªŒé€šè¿‡ï¼Œè¿›å…¥ç¬¬äºŒæ¬¡æ­»å¾ªç¯
            for (;;) {
              //å·¥ä½œçº¿ç¨‹ä¸ªæ•°ã€çº¿ç¨‹æ± æœ€å¤§çº¿ç¨‹å®¹é‡ã€‘
              //coreä¸ºå¤–éƒ¨ä¼ å…¥çš„ï¼Œtrueä»£è¡¨åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹åˆ›å»ºä»»åŠ¡ï¼Œfalseä»£è¡¨ä½¿ç”¨æ ¸å¿ƒçº¿ç¨‹å¤–çš„æœ€å¤§çº¿ç¨‹åˆ›å»ºä»»åŠ¡
              //åˆ¤æ–­å·¥ä½œçº¿ç¨‹æ•°æ˜¯å¦å¤§äºæ ¸å¿ƒçº¿ç¨‹æ•°æˆ–è€…å¤§äºæœ€å¤§çº¿ç¨‹æ•°ï¼Œå¤§äºçš„è¯ï¼Œä¹Ÿä¸åˆ›å»ºï¼Œæ„å»ºå·¥ä½œçº¿ç¨‹å¤±è´¥ï¼Œç›´æ¥é€€å‡º
                if (workerCountOf(c)
                    >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))
                  //æ„å»ºå·¥ä½œçº¿ç¨‹å¤±è´¥ï¼Œç›´æ¥é€€å‡º
                    return false;
              //ä½¿ç”¨CASï¼Œå°†å·¥ä½œçº¿ç¨‹æ•°+1
                if (compareAndIncrementWorkerCount(c))
                  //æˆåŠŸå°±é€€å‡ºå¤–ä¾§forå¾ªç¯
                    break retry;
              //CASå¤±è´¥ï¼Œä¼šé‡æ–°è·å–CTLï¼Œå¤±è´¥åŸå› åªæœ‰ä¸€ä¸ªï¼Œæœ‰çº¿ç¨‹å¹¶å‘æ“ä½œ
                c = ctl.get();  // Re-read ctl
              //åˆ¤æ–­çº¿ç¨‹çŠ¶æ€ï¼Œæ˜¯å¦æœ‰å˜åŒ–ï¼Œæ˜¯å¦ä¸ºéRUNNING
                if (runStateAtLeast(c, SHUTDOWN))
                  //æ˜¯çš„è¯ç›´æ¥é€€å‡ºåˆ°å¤–å±‚å¾ªç¯ï¼Œåœ¨èµ°ä¸€æ¬¡
                    continue retry;
              //å¦‚æœä¸ºrunningï¼Œåœ¨å†…å±‚åœ¨å¾ªç¯ä¸€æ¬¡å°±è¡Œäº†
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
//å¼€å§‹çœŸæ­£åˆ›å»ºworkerå·¥ä½œçº¿ç¨‹
  //workerå¼€å§‹=false
        boolean workerStarted = false;
  //workeræ·»åŠ =false
        boolean workerAdded = false;
        Worker w = null;
        try {
          //åˆ›å»ºworkerå¯¹è±¡ï¼Œä¼ å…¥å·¥ä½œä»»åŠ¡
            w = new Worker(firstTask);
            final Thread t = w.thread;
          //è·å–å‡ºçš„ä»»åŠ¡ä¸ä¸ºç©º
            if (t != null) {
              //è·å–çº¿ç¨‹æ± çš„å…¨å±€é”ï¼Œé¿å…å½“å‰çº¿ç¨‹åœ¨æ·»åŠ ä»»åŠ¡æ—¶ï¼Œåˆ«çš„çº¿ç¨‹è¿›å…¥æ“ä½œï¼Œç»“æŸäº†çº¿ç¨‹æ± ï¼Œæ‰€ä»¥åŠ é”ï¼Œè¦æƒ³ç»“æŸçº¿ç¨‹æ± ï¼Œéœ€è¦å…ˆè·å–åˆ°è¿™ä¸ªå…¨å±€é”
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                  //è·å–çº¿ç¨‹æ± çŠ¶æ€
                    int c = ctl.get();
                  //çº¿ç¨‹è¿˜æœªè¿è¡Œï¼ŒçŠ¶æ€å°±æ”¹å˜äº†ï¼Œå°±è¦æŠ›å‡ºéæ³•çš„çº¿ç¨‹çŠ¶æ€å¼‚å¸¸ï¼ŒfirstTask == nullæ˜¯å¤„ç†é˜»å¡é˜Ÿåˆ—æœ‰ä»»åŠ¡ï¼Œä½†æ˜¯æ²¡æœ‰å·¥ä½œçº¿ç¨‹ï¼Œè¿™æ—¶å€™å°±éœ€è¦æ·»åŠ ä¸€ä¸ªä»»åŠ¡ä¸ºç©ºçš„å·¥ä½œçº¿ç¨‹å»å¤„ç†é˜»å¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
                    if (isRunning(c) ||
                        (runStateLessThan(c, STOP) && firstTask == null)) {
                        if (t.getState() != Thread.State.NEW)
                            throw new IllegalThreadStateException();
                      //æ·»åŠ worker
                        workers.add(w);
                      //æ·»åŠ workerå·¥ä½œçº¿ç¨‹æˆåŠŸ
                        workerAdded = true;
                      //å¦‚æœå·¥ä½œçº¿ç¨‹æ•°ï¼Œå¤§äºä¹‹å‰è®°å½•çš„çº¿ç¨‹æ•°ï¼Œå°±æ›¿æ¢ä¸€ä¸‹çº¿ç¨‹æ•°ï¼Œä»£è¡¨çº¿ç¨‹æ•°å·²ç»æ›´æ–°æˆåŠŸ
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                    }
                } finally {
                  //é‡Šæ”¾ReentrantLock
                    mainLock.unlock();
                }
                if (workerAdded) {
                  //æ·»åŠ æˆåŠŸï¼Œå¯åŠ¨å·¥ä½œçº¿ç¨‹
                    t.start();
                  //å¯åŠ¨å·¥ä½œçº¿ç¨‹æˆåŠŸ
                    workerStarted = true;
                }
            }
        } finally {
          //å¦‚æœå¯åŠ¨å·¥ä½œçº¿ç¨‹å¤±è´¥ï¼Œä»å·¥ä½œçº¿ç¨‹workersä¸­ç§»é™¤æ·»åŠ çš„workerå·¥ä½œçº¿ç¨‹ï¼Œé‡ç½®çº¿ç¨‹æ•°
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

#### Workerå°è£…

çº¿ç¨‹ä¸­æ”¾çš„runnableï¼Œå…¶å®å°±æ˜¯workerå¯¹è±¡ï¼Œå½“çº¿ç¨‹.startçš„æ—¶å€™ï¼Œå…¶å®å°±æ˜¯æ‰§è¡Œçš„workerçš„runæ–¹æ³•

```java
//å®ç°äº†Runnableï¼Œé‚£ä¹ˆè‚¯å®šé‡å†™äº†Runæ–¹æ³•
    private final class Worker extends AbstractQueuedSynchronizer implements Runnable
    {
        /**
         * This class will never be serialized, but we provide a
         * serialVersionUID to suppress a javac warning.
         */
        private static final long serialVersionUID = 6138294804551838833L;

        /** Thread this worker is running in.  Null if factory fails. */
        @SuppressWarnings("serial") // Unlikely to be serializable
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        @SuppressWarnings("serial") // Not statically typed as Serializable
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;
      //æœ‰å‚æ„é€ ï¼Œå°†çº¿ç¨‹æ± çš„ä»»åŠ¡ä¼ å…¥ç»™worker
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
          //æ ¸å¿ƒä»£ç ï¼Œè°ƒç”¨å·¥ä½œä»£ç çš„startï¼Œèµ°çš„æ˜¯workerçš„runæ–¹æ³•
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker. */
        public void run() {
            runWorker(this);
        }
    }
```

#### runWorker

```java
final void runWorker(Worker w) {
  //è·å–å½“å‰çº¿ç¨‹
    Thread wt = Thread.currentThread();
  //æ‹¿åˆ°ä¼ å…¥çš„ä»»åŠ¡
    Runnable task = w.firstTask;
  //AQS
    w.firstTask = null;
    w.unlock(); // allow interrupts
  //æ ‡è¯†ä¸ºtrue
    boolean completedAbruptly = true;
    try {
      //å¦‚æœä»»åŠ¡ä¸ä¸ºç©º || å¦‚æœä»»åŠ¡ä¸ºç©ºï¼Œå°±ä»é˜»å¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡
      //task = getTask()é˜»å¡é˜Ÿåˆ—å°±åœ¨è¿™é‡Œé˜»å¡çš„ï¼Œç­‰å¾…çº¿ç¨‹æ± ç©ºé—²ï¼Œä¼šè°ƒç”¨parkæ–¹æ³•ï¼Œè¿›è¡Œçº¿ç¨‹é˜»å¡
        while (task != null || (task = getTask()) != null) {
          //åŠ é”ï¼Œé¿å…çº¿ç¨‹æ± è¢«shutdown
            w.lock();
          //åˆ¤æ–­å½“å‰çº¿ç¨‹æ± çŠ¶æ€æ˜¯å¦å¤§äºç­‰äºSTOPï¼ŒçŠ¶æ€ä¸ºTERMINATED
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
              //ä¸­æ–­è¯¥çº¿ç¨‹
                wt.interrupt();
            try {
              //æ‰§è¡Œä»»åŠ¡å‰æ“ä½œï¼Œæ¨¡æ¿æ–¹æ³•ï¼Œå¯ä»¥è‡ªå·±é‡å†™
                beforeExecute(wt, task);
                try {
                  //å¼€å§‹æ‰§è¡Œä»»åŠ¡
                    task.run();
                  //æ‰§è¡Œä»»åŠ¡åæ“ä½œï¼Œæ¨¡æ¿æ–¹æ³•ï¼Œå¯ä»¥è‡ªå·±é‡å†™
                    afterExecute(task, null);
                } catch (Throwable ex) {
                  //æ‰§è¡Œä»»åŠ¡åæ“ä½œï¼Œæ¨¡æ¿æ–¹æ³•ï¼Œå¯ä»¥è‡ªå·±é‡å†™
                    afterExecute(task, ex);
                    throw ex;
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

#### submit

```java
public <T> Future<T> submit(Callable<T> task) {
    if (task == null) throw new NullPointerException();
  //å°†ä¼ å…¥çš„taskå°è£…ä¸ºä¸€ä¸ªRunnableFutureå¯¹è±¡ï¼Œ
    RunnableFuture<T> ftask = newTaskFor(task);
  //å°†ä»»åŠ¡æäº¤ç»™çº¿ç¨‹æ± 
    execute(ftask);
    return ftask;
}

    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        return new FutureTask<T>(callable);
    }

		//FutureTaskæ„é€ æ–¹æ³•ï¼ŒåŠ callableå­˜ä¸‹ï¼Œç„¶åå°†ä»»åŠ¡çŠ¶æ€è®¾ç½®ä¸ºNEW
    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }
```

## FutureTaskä½¿ç”¨ç¤ºä¾‹

FutureTaskæ˜¯é…åˆçº¿ç¨‹æ± ä½¿ç”¨çš„ï¼Œå°†ä»»åŠ¡submitåˆ°çº¿ç¨‹æ± ä¸­ï¼Œçº¿ç¨‹æ± å®‰æ’çº¿ç¨‹æ‰§è¡Œ

### å®ä¾‹ä¸€

```java
public class FutureDemo {
      public static void main(String[] args) {
          ExecutorService executorService = Executors.newCachedThreadPool();
          Future future = executorService.submit(new Callable<Object>() {
              @Override
              public Object call() throws Exception {
                  Long start = System.currentTimeMillis();
                  while (true) {
                      Long current = System.currentTimeMillis();
                     if ((current - start) > 1000) {
                         return 1;
                     }
                 }
             }
         });
         try {
             Integer result = (Integer)future.get();
             System.out.println(result);
         }catch (Exception e){
             e.printStackTrace();
         }
     }
}

```

### å®ä¾‹ä¸€æ‰§è¡Œæµç¨‹

1. Mainçº¿ç¨‹å¼€å¯çº¿ç¨‹æ± 
2. Mainæäº¤ä»»åŠ¡ï¼Œè¿”å›ä»»åŠ¡å¥æŸ„

![image-20220731160912165](/Users/hhh/Library/Application Support/typora-user-images/image-20220731160912165.png)

3. ä¸»çº¿ç¨‹è¿”å›çš„Futureå¯¹è±¡æ˜¯ä»submitæ–¹æ³•è¿”å›ï¼ŒnewTaskForï¼Œæ–°å»ºäº†ä¸€ä¸ªFutureTaskå¯¹è±¡ï¼Œå¹¶è¿”å›ï¼Œ`FutureTask<V> implements RunnableFuture<V> `ï¼ŒFutureTaské‡å†™äº†runæ–¹æ³•ï¼Œæ‰€ä»¥æäº¤åˆ°çº¿ç¨‹æ± ä¸­çš„ä»»åŠ¡ï¼Œç­‰ä¼šä¼šå›è°ƒå›Future Taskçš„runï¼Œå°†ä»»åŠ¡äº¤ç»™çº¿ç¨‹æ± è¿›è¡Œexecute

![image-20220731161052452](/Users/hhh/Library/Application Support/typora-user-images/image-20220731161052452.png)

![image-20220731161152457](/Users/hhh/Library/Application Support/typora-user-images/image-20220731161152457.png)

![image-20220731161349281](/Users/hhh/Library/Application Support/typora-user-images/image-20220731161349281.png)



4. å°†æäº¤çš„ä»»åŠ¡ï¼Œæ·»åŠ åˆ°å·¥ä½œé˜Ÿåˆ—ä¸­ï¼Œ**æ³¨æ„ï¼šæ˜¯å°†FutureTaskå¯¹è±¡æäº¤åˆ°äº†çº¿ç¨‹æ± ä¸­ï¼Œç„¶åå›è°ƒåˆ°äº†FetureTaskå¯¹è±¡ï¼Œç”±FetureTaskå¯¹è±¡ï¼Œè°ƒç”¨callæ–¹æ³•çœŸæ­£æ‰§è¡Œä»»åŠ¡**

![image-20220731161824795](/Users/hhh/Library/Application Support/typora-user-images/image-20220731161824795.png)

![image-20220731162142639](/Users/hhh/Library/Application Support/typora-user-images/image-20220731162142639.png)

![image-20220731162532398](/Users/hhh/Library/Application Support/typora-user-images/image-20220731162532398.png)

5.å¼€å¯æ–°çº¿ç¨‹ï¼ŒThread-1ï¼Œçº¿ç¨‹å›è°ƒåˆ°ç”³è¯·çº¿ç¨‹çš„FeatureTaskç±»runæ–¹æ³•ï¼ŒåŒæ—¶ï¼ŒMainçº¿ç¨‹ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œè°ƒç”¨getæ–¹æ³•ï¼Œæœ€ç»ˆä¼šåœ¨awaitDoneä¸­ï¼Œè¢«parkä½ï¼Œç­‰å¾…ä»»åŠ¡æ‰§è¡Œå®Œæˆåå”¤é†’

![image-20220731163239492](/Users/hhh/Library/Application Support/typora-user-images/image-20220731163239492.png)

![image-20220731163322700](/Users/hhh/Library/Application Support/typora-user-images/image-20220731163322700.png)

## FutureTaskå®è·µ

FutureTaskéœ€è¦ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œç°ä½¿ç”¨tomcatå¼€è¾Ÿçº¿ç¨‹æ± çš„æ–¹å¼ï¼Œå¼€å¯çº¿ç¨‹

- ä»£ç æŠ„çš„embed tomcat org.apache.tomcat.util.net.AbstractEndpoint#createExecutor()
- å¦‚æœéœ€è¦å¯¹tomcatè¿›è¡Œè°ƒä¼˜ï¼Œé‚£ä¹ˆè¯¥é¡¹ç›®çš„çº¿ç¨‹æ± å‚æ•°ï¼Œä¹Ÿä¼šæ ¹æ®tomcat çš„é…ç½®è¿›è¡Œè°ƒæ•´
- è¯¥ç±»ä¸ºæ‡’æ±‰å¼å•ä¾‹ï¼Œä½¿ç”¨synchronizedä¿è¯æœ¬æœ‰çŠ¶æ€çš„beanå•ä¾‹çº¿ç¨‹å®‰å…¨

```java
@Component
public class ContractCenterThreadExecutor {
    @Autowired
    private ApplicationContext applicationContext;
    private ThreadPoolExecutor executor = null;
    @Autowired
    private ServerProperties serverProperties;

    public synchronized ExecutorService getExecutorService() {
        if (executor != null) {
            return executor;
        }
        TaskQueue taskqueue = new TaskQueue();
        ServerProperties.Tomcat.Threads threads = serverProperties.getTomcat().getThreads();
        boolean daemon = true;
        TaskThreadFactory tf = new TaskThreadFactory(applicationContext.getId() + "-exec-", daemon, Thread.NORM_PRIORITY);
        executor = new ThreadPoolExecutor(threads.getMinSpare(), threads.getMax(), 60, TimeUnit.SECONDS, taskqueue, tf);
        taskqueue.setParent(executor);
        return executor;
    }
}
```

### feignä½¿ç”¨

- SynchronousMethodHandlerï¼Œfeign.SynchronousMethodHandler#executeAndDecodeæ–¹æ³•ï¼Œå¯¹requestè¿›è¡Œç»„è£…æ—¶ï¼Œéœ€è¦å°†çº¿ç¨‹å˜é‡è®¾ç½®åˆ°æ–°å¼€å¯çš„çº¿ç¨‹ä¸­
- feign.SynchronousMethodHandler#targetRequest ç»„è£…feign requestï¼Œä¼šå¯¹æ³¨å†Œåˆ°ç³»ç»Ÿçš„RequestInterceptoræ‹¦æˆªå™¨æ‰§è¡Œ
- åœ¨ç¼–å†™callbackæ—¶ï¼Œéœ€è¦å°†å½“å‰çº¿ç¨‹å˜é‡è®¾ç½®åˆ°æ–°å¼€çº¿ç¨‹çš„thread localä¸­

![image-20221116164730777](/Users/hhh/Library/Application Support/typora-user-images/image-20221116164730777.png)

## BlockingQueue





