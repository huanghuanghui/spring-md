# ComponentScan
[toc]

## 简介
@ComponentScan的功能是，将扫描到的组件加入spring容器中，默认情况下，扫描的是@Component注解，@ComponentScan支持自己配置扫描方式，配置方式下文解析。

## 属性解析
```java
@Repeatable(ComponentScans.class)
public @interface ComponentScan {
	//与basePackages互为AliasFor，他们可以互相为别名，表示需要扫包的路径，默认是当前传入的配置类当前路径+包以下路径
	@AliasFor("basePackages")
	String[] value() default {};
	//作用与value相同，目的是为了我们可以使用value属性，却可以省略写value=“xxx”
	@AliasFor("value")
	String[] basePackages() default {};
	//扫描的类，会扫描该类所在包及其子包的组件
	Class<?>[] basePackageClasses() default {};
	//bean生成器
	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;
	//用来解析bean的scope的属性，例如Spring中提供了@Scope注解，用来定义bean的单例还是多例，默认是单例
	Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;
	//用来配置代理方式,默认3种，默认NO，NO：不代理/INTERFACES：JDK/TARGET_CLASS：CGLIB
	ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;
	//定义扫描的规则 DEFAULT_RESOURCE_PATTERN=**/*.class
	String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;
	//是否使用默认的过滤器，默认为true，spring 默认会自动发现被 @Component、@Repository、@Service 和 @Controller 标注的类，并注册进容器中。要达到只包含某些包的扫描效果，就必须将这个默认行为给禁用
	boolean useDefaultFilters() default true;
	//按照规则只包含某些包的扫描
	Filter[] includeFilters() default {};
	//按照规则排除某些包的扫描
	Filter[] excludeFilters() default {};
	//设置为延迟加载，spring将不实例化当前ComponentScan扫描到的所有bean，在第一次调用getBean才会将bean进行实例化
	boolean lazyInit() default false;
	//过滤器
	@Retention(RetentionPolicy.RUNTIME)
	@Target({})
	@interface Filter {
		//扫描规则，默认注解，有5种ANNOTATION,ASSIGNABLE_TYPE,ASPECTJ,REGEX,CUSTOM
		FilterType type() default FilterType.ANNOTATION;
		//特定类
		@AliasFor("classes")
		Class<?>[] value() default {};
		//
		@AliasFor("value")
		Class<?>[] classes() default {};
		//
		String[] pattern() default {};

	}

}
```

## 属性源码解析

### basePackages/value/basePackageClasses

```java
		//从注解中取出basePackages属性值
		String[] basePackagesArray = componentScan.getStringArray("basePackages");
		for (String pkg : basePackagesArray) {
			//若配置不为空，将字符串按照指定的字符转换成String[]数组，如字符串中不包含指定字符，则将整个字符串放进数组。如指定字符有多个，
			// 是分别按单个字符来切割的。 例如basePackages为： “org.hhh,org.mytest” 指定字符： “,;\t\n” 返回数组：[org.hhh, org.mytest]对应包下的文件都会被扫描
			//this.environment.resolvePlaceholders(pkg)支持EL表达式，例如：scanBasePackages = "${my.url}"，会被当作配置进行加载
			String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
					ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
			Collections.addAll(basePackages, tokenized);
		}
		//如果basePackageClasses不为空，将其类所在的包加入basePackages，会扫描加入类及其子包下的所有组件
		for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
			basePackages.add(ClassUtils.getPackageName(clazz));
		}
		//如果basePackages为空，默认扫描当前类及其子包，SpringbootApplication中常用
		if (basePackages.isEmpty()) {
			basePackages.add(ClassUtils.getPackageName(declaringClass));
		}
```

### nameGenerator
```java
		//从注解中取出nameGenerator配置
		Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
		//判断nameGenerator是不是=默认的BeanNameGenerator
		boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
		//如果自己没有重写，那么默认使用AnnotationBeanNameGenerator，否则使用我们自定义的
		scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator : BeanUtils.instantiateClass(generatorClass));

```
beanName生成器，接口为：BeanNameGenerator，有2个实现类
- DefaultBeanNameGenerator：xml bean名称生成，基本废弃
- AnnotationBeanNameGenerator：注解bean名称生成，默认使用

```java
	public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {
		//如果是打上注解的bean，进入这个判断，执行步骤为，取出注解中的bean名称，如果有指定bean name，直接返回
		if (definition instanceof AnnotatedBeanDefinition) {
			String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);
			if (StringUtils.hasText(beanName)) {
				// Explicit bean name found.
				return beanName;
			}
		}
		// 生成默认的唯一的bean名称，其实就是类的首字母小写的bean名称
		return buildDefaultBeanName(definition, registry);
	}
```
我们可以重写BeanNameGenerator，指定bean名称的生成，走我们自己策略。例如在所有bean名称前加上包名第一个单词，只改buildDefaultBeanName，如果有自己指定beanName，那么走AnnotationBeanNameGenerator，否则走我们自定义的buildDefaultBeanName
```java
public class MyNameGenerator extends AnnotationBeanNameGenerator {
    @Override
    protected String buildDefaultBeanName(BeanDefinition definition) {
        String beanClassName = definition.getBeanClassName();
        Assert.state(beanClassName != null, "No bean class name set");
        //分割类全路径
        String[] packages = beanClassName.split("\\.");
        StringBuilder beanName = new StringBuilder();
        //取类的包名的首字母小写再加上类名作为最后的bean名
        for (int i = 0; i < packages.length - 1; i++) {
            beanName.append(packages[i].toLowerCase().charAt(0));
        }
        beanName.append(packages[packages.length - 1]);
        return beanName.toString();
    }
}

```

### scopeResolver与scopedProxy

```java
		//获取scopedProxy属性
		ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
		//判断是否为默认的代理类型，DEFAULT指默认不代理
		if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
			//如果自定义了代理类型，那么就会拉起一个AnnotationScopeMetadataResolver对象，将代理模式存入
			scanner.setScopedProxyMode(scopedProxyMode);
		} else {
			//scopeResolver与scopedProxy是互斥的
			//scopedProxyMode=DEFAULT，将默认的AnnotationScopeMetadataResolver存入，如果自己有重写，将自己的代理类存入
			Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
			scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
		}
```

从代码可以看出scopeResolver与scopedProxy是互斥的，配置了一个就无法配置另一个，他们都是为了拉起一个AnnotationScopeMetadataResolver对象，对象中存入默认的代理类型。AnnotationScopeMetadataResolver主要负责对Scope注解的解析，ScopeMetadata就是对Scope注解的描述转换，以Metadata结尾命名的表示对元数据(注解)的描述，AnnotationScopeMetadataResolver#resolveScopeMetadata()方法解析注解 Bean 定义类的作用域元信息，即判断注册的 Bean 是原生类型(prototype)还是单态(singleton)类型。具体的配合使用可以参考类：AnnotationScopeMetadataResolverTests
```java
	public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) {
		ScopeMetadata metadata = new ScopeMetadata();
		if (definition instanceof AnnotatedBeanDefinition) {
			//在扫描过程中add的是ScannedGenericBeanDefinition
			//从注解BeanDefinition 获取Scope的属性，@Scope所标注的值
			AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;
			//将bean所有的注解解析后存放到map中
			AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(annDef.getMetadata(), this.scopeAnnotationType);
			if (attributes != null) {
				//设置Scope
				metadata.setScopeName(attributes.getString("value"));
				//获取@Scope中的proxyMode， 设置proxyMode，在创建代理对象时候使用
				ScopedProxyMode proxyMode = attributes.getEnum("proxyMode");
				//如果代理类型为DEFAULT或者NO，
				if (proxyMode == ScopedProxyMode.DEFAULT) {
					//设置proxyMode为NO
					proxyMode = this.defaultProxyMode;
				}
				//为返回的元数据设置proxyMode
				metadata.setScopedProxyMode(proxyMode);
			}
		}
		return metadata;
	}
```

```java
public class ScopeMetadata {

	private String scopeName = BeanDefinition.SCOPE_SINGLETON;

	private ScopedProxyMode scopedProxyMode = ScopedProxyMode.NO;


	/**
	 * Set the name of the scope.
	 */
	public void setScopeName(String scopeName) {
		Assert.notNull(scopeName, "'scopeName' must not be null");
		this.scopeName = scopeName;
	}

	/**
	 * Get the name of the scope.
	 */
	public String getScopeName() {
		return this.scopeName;
	}

	/**
	 * Set the proxy-mode to be applied to the scoped instance.
	 */
	public void setScopedProxyMode(ScopedProxyMode scopedProxyMode) {
		Assert.notNull(scopedProxyMode, "'scopedProxyMode' must not be null");
		this.scopedProxyMode = scopedProxyMode;
	}

	/**
	 * Get the proxy-mode to be applied to the scoped instance.
	 */
	public ScopedProxyMode getScopedProxyMode() {
		return this.scopedProxyMode;
	}

}

```
### resourcePattern
默认的resourcePattern为  DEFAULT_RESOURCE_PATTERN = "**/*.class";指默认扫描所有文件夹下的所有类

### useDefaultFilters
是否使用默认的过滤器，默认为true，spring 默认会自动发现被 @Component、@Repository、@Service 和 @Controller 标注的类，并注册进容器中。要达到只包含某些包的扫描效果，就必须将这个默认行为给禁用ClassPathBeanDefinitionScanner#ClassPathBeanDefinitionScanner()
```java
		ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
				componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);
```
useDefaultFilters默认=true，会默认将@Component加入扫描，那么@Component/@Service/@Controller/@Repository都会被加入扫描
```java
	protected void registerDefaultFilters() {
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));
	}
```
### includeFilters与excludeFilters
includeFilters与excludeFilters可以自定义需要扫描的类与需要排除扫描的类，扫描类型如下：

```java
public enum FilterType {
	ANNOTATION,//按照注解方式
	ASSIGNABLE_TYPE,//按照指定类型的方式
	ASPECTJ,//使用ASPECTJ表达式的方式
	REGEX,//利用正则表达式进行指定
	CUSTOM//自己实现TypeFilter接口进行自定义规则 实现org.springframework.core.type.filter.TypeFilter} implementation.
}```
写法：
```java
@ComponentScan(value = "org.hhh",
        includeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,classes = Controller.class),
        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,classes = MyLazyBean.class),
        @ComponentScan.Filter(type = FilterType.CUSTOM,classes = MyFilter.class)
}
)
```
其中配置的类都会被存储到ClassPathScanningCandidateComponentProvider的includeFilters与excludeFilters中


### lazyInit
```java
@ComponentScan(value = "org.hhh",lazyInit = true)
public class AppConfig {

}
```
配置类是否延迟加载，例如如上配置类，@ComponentScan加了lazyInit = true，但是配置类AppConfig不会延迟加载，只有它扫描出来的类，才支持延迟加载。配置类在register阶段就会被加载，没传入qualifiers，所以不会加载他的配置，配置类本身想延迟加载，需要配置@Lazy
```java
	public AnnotationConfigApplicationContext(Class<?>... componentClasses) {

		this();
		//AnnotationsScanner.getDeclaredAnnotations() 获取类上的所有注解，存入缓存declaredAnnotationCache
		//注册配置类的BeanDefinition
		register(componentClasses);
		refresh();
	}

	public void registerBean(Class<?> beanClass) {
		doRegisterBean(beanClass, null, null, null, null);
	}
```