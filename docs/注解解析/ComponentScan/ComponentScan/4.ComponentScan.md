# ComponentScan
[toc]

## 简介
@ComponentScan的功能是，将扫描到的组件加入spring容器中，默认情况下，扫描的是@Component注解，@ComponentScan支持自己配置扫描方式，配置方式下文解析。

## 属性解析
```java
@Repeatable(ComponentScans.class)
public @interface ComponentScan {
	//与basePackages互为AliasFor，他们可以互相为别名，表示需要扫包的路径，默认是当前传入的配置类当前路径+包以下路径
	@AliasFor("basePackages")
	String[] value() default {};
	//作用与value相同，目的是为了我们可以使用value属性，却可以省略写value=“xxx”
	@AliasFor("value")
	String[] basePackages() default {};
	//扫描的类，会扫描该类所在包及其子包的组件
	Class<?>[] basePackageClasses() default {};
	//bean生成器
	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;
	//用来解析bean的scope的属性，例如Spring中提供了@Scope注解，用来定义bean的单例还是多例，默认是单例
	Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;
	//用来配置代理方式,默认3种，默认NO，NO：不代理/INTERFACES：JDK/TARGET_CLASS：CGLIB
	ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;
	//定义扫描的规则
	String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;
	//是否使用默认的过滤器，默认为true，spring 默认会自动发现被 @Component、@Repository、@Service 和 @Controller 标注的类，并注册进容器中。要达到只包含某些包的扫描效果，就必须将这个默认行为给禁用
	boolean useDefaultFilters() default true;
	//按照规则只包含某些包的扫描
	Filter[] includeFilters() default {};
	//按照规则排除某些包的扫描
	Filter[] excludeFilters() default {};
	//设置为延迟加载，spring将不实例化当前ComponentScan扫描到的所有bean，在第一次调用getBean才会将bean进行实例化
	boolean lazyInit() default false;
	//过滤器
	@Retention(RetentionPolicy.RUNTIME)
	@Target({})
	@interface Filter {
		//扫描规则，默认注解，有5种ANNOTATION,ASSIGNABLE_TYPE,ASPECTJ,REGEX,CUSTOM
		FilterType type() default FilterType.ANNOTATION;
		//特定类
		@AliasFor("classes")
		Class<?>[] value() default {};
		//
		@AliasFor("value")
		Class<?>[] classes() default {};
		//
		String[] pattern() default {};

	}

}
```

## 属性源码解析

### basePackages与value

```java
		//从注解中取出basePackages属性值
		String[] basePackagesArray = componentScan.getStringArray("basePackages");
		for (String pkg : basePackagesArray) {
			//若配置不为空，将字符串按照指定的字符转换成String[]数组，如字符串中不包含指定字符，则将整个字符串放进数组。如指定字符有多个，
			// 是分别按单个字符来切割的。 例如basePackages为： “org.hhh,org.mytest” 指定字符： “,;\t\n” 返回数组：[org.hhh, org.mytest]对应包下的文件都会被扫描
			//this.environment.resolvePlaceholders(pkg)支持EL表达式，例如：scanBasePackages = "${my.url}"，会被当作配置进行加载
			String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
					ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
			Collections.addAll(basePackages, tokenized);
		}
		//如果basePackageClasses不为空，将其类所在的包加入basePackages，会扫描加入类及其子包下的所有组件
		for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
			basePackages.add(ClassUtils.getPackageName(clazz));
		}
		//如果basePackages为空，默认扫描当前类及其子包，SpringbootApplication中常用
		if (basePackages.isEmpty()) {
			basePackages.add(ClassUtils.getPackageName(declaringClass));
		}
```
