# @Bean

## 简介
@Bean是Spring用来生成注册bean的注解，一般与@Configuration配合使用，其中Full与Lite的区别，参考@Configuration的解析。@Bean与@Component都是Spring中用来注册bean的注解，两者有相同点也有不同点。

- 相同点
    - 两者都是用来注册bean的Spring容器中
    - 都要在@ComponentScan的扫描路径下，才能被扫描出来，被注册成为bean
- 不同点
    - @Component（@Service/@Controller/@Respository/@Configuration）是标注在类上的注解，整个类都会被注册为bean
    - @Bean标注在方法上，表示当前方法返回的对象，需要注册为bean，在Spring扩展中，一般使用@Import+@Configuration+@Bean来往容器中注入bean


## 属性解析

```java
public @interface Bean {
    //name 与value互为别名，作用是声明的bean的alias，默认第一个值是primary的bean name，不然会导致alias循环引用，没配置默认bean名称为method name
	@AliasFor("name")
	String[] value() default {};

	@AliasFor("value")
	String[] name() default {};

    //这个 bean 是否可以自动装配到其他 bean 中？ 默认为 true将其设置为 false 用于不打算妨碍其他地方相同类型 bean 的内部委托。指的是，比如同时有serviceA与serviceB，type=MyService，Spring在注入的时候，无法选择，如果不设置primary，可以设置一个bean不能被作为注入候选者，这样Spring就可以找到serviceA进行注入
	boolean autowireCandidate() default true;

    //Spring bean的生命周期，指定init的时候，执行bean中的什么方法，写法为@Bean(initMethod = "init")，init为方法名，效果与@PostConstruct一致
	String initMethod() default "";

    //Spring bean的生命周期，指定destroy的时候，执行bean中的什么方法，写法为@Bean(initMethod = "destroy")，destroy为方法名，效果与@PreDestroy一致
	String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;

}

```

## Spring @Bean Doc

声明一个方法生成一个由 Spring 容器管理的 bean。此注解的属性名称和语义有意与 Spring XML 模式中的 {@code <bean>} 元素相似。例如：
```java
@Bean
public MyBean myBean() {
    // instantiate and configure MyBean obj
    return obj;
}
```
### bean名称
虽然 name 属性可用，但确定 bean 名称的默认策略是使用 @Bean 方法的名称。这既方便又直观，但如果需要显式命名，可以使用 name 属性（或其别名value）。另请注意， name 接受一个字符串数组，允许单个 bean 有多个名称（即一个主 bean 名称加上一个或多个别名）。

```java
//有效的bean名称是b1 b2 而不是myBean
 @Bean({"b1", "b2"})
 public MyBean myBean() {
     // instantiate and configure MyBean obj
     return obj;
 }
```
### Profile, Scope, Lazy, DependsOn, Primary, Order注解
@Bean 注释不提供配置文件、范围、惰性、依赖或主要的属性。相反，它应该与@Profile,@Scope, @Lazy, @DependsOn, @Primary, @Order 注释一起使用来声明这些语义。例如：
```java
 @Bean
 @Profile("production")
 @Scope("prototype")
 public MyBean myBean() {
     // instantiate and configure MyBean obj
     return obj;
 }
```
上述注解的语义与它们在组件类级别的使用相匹配：
- @Profile 允许选择性地包含某些 bean。
- @Scope 将 bean 的范围从单例更改为指定范围。 
- @Lazy 只有在默认单例范围的情况下才有实际效果。 
- @DependsOn 强制在创建此 bean 之前创建特定的其他 bean，除了通过直接引用表示的 bean 的任何依赖关系，这通常有助于单例启动。 
- @Primary 是一种在注入点级别解决歧义的机制，如果需要注入单个目标组件但多个 bean 按类型匹配。

此外， @Bean 方法还可以声明限定符注解和 @Order 值，以便在注入点解析期间考虑，就像相应组件类上的相应注解一样但每个 bean 定义可能非常独立（如果有多个定义具有相同的 bean 类）。限定符在初始类型匹配后缩小候选集；在集合注入点的情况下， order 值确定已解析元素的顺序（多个目标 bean 按类型和限定符匹配）。

注意：@Order 值可能会影响注入点的优先级，但请注意，它们不会影响单例启动顺序，这是由依赖关系和 确定的正交问题 @DependsOn 声明如上所述。此外，@Priority 在此级别不可用，因为它不能在方法上声明；它的语义可以通过 @Order 值结合 @Primary 在每个类型的单个 bean 上进行建模。

通常， @Bean 方法在 @Configuration 类中声明。在这种情况下，bean 方法可以通过直接调用同一类中的其他@Bean方法。这确保了 bean 之间的引用是强类型和可导航的。这种所谓的`inter-bean references`保证尊重范围和 AOP 语义，就像 getBean() 查找一样。这些是原始“Spring JavaConfig”项目中已知的语义，它需要在运行时对每个此类配置类进行 CGLIB 子类化。因此，在此模式下，@Configuration 类及其工厂方法不得标记为 final 或 private。例如：
```java
@Configuration
 public class AppConfig {
     @Bean
     public FooService fooService() {
         return new FooService(fooRepository());
     }
     @Bean
     public FooRepository fooRepository() {
         return new JdbcFooRepository(dataSource());
     }
     // ...
 }

```
### @Bean Lite模式
@Bean 方法也可以在 不用 @Configuration 注释的类中声明。例如，bean 方法可以在 @Component类中声明，甚至可以在普通的旧类中声明。在这种情况下，@Bean方法将以所谓的Lite 模式进行处理。 Lite 模式下的 Bean 方法将被容器视为普通的factoryMethod（类似于 XML 中的 factory-method 声明），具有范围和生命周期回调正确应用。在这种情况下，包含类保持不变，并且包含类或工厂方法没有异常约束。 

与 @Configuration类中 bean 方法的语义相比，`inter-bean references`(默认的调用getBean的增强代理)在lite模式下不受支持。相反，当一个 @Bean 方法以 lite 模式调用另一个 @Bean 方法时，调用是标准的 Java 方法调用； Spring 不会通过 CGLIB 代理拦截调用。这类似于在代理模式下的 inter-@Transactional 方法调用，Spring 不拦截调用——Spring 仅在 AspectJ 模式下这样做。

必须特别考虑返回 Spring BeanFactoryPostProcessor 类型的 @Bean 方法。因为BeanFactoryPostProcessor 对象必须在容器生命周期的早期实例化，它们可能会干扰 @Bean 中的  @Autowired、 @Value 和 @PostConstruct 等注释的处理代码@Configuration 类。为避免这些生命周期问题，请将 BeanFactoryPostProcessor-returning @Bean 方法标记为 static。例如：

```java
@Bean
public static PropertySourcesPlaceholderConfigurer pspc() {
    // instantiate, configure and return pspc ...
}
```

通过将此方法标记为static，可以在不引起其声明的@Configuration 类的实例化的情况下调用它，从而避免上述生命周期冲突。但是请注意，如上所述，static @Bean 方法不会针对作用域和 AOP 语义进行增强。这适用于 BFPP 情况，因为它们通常不会被其他  @Bean 方法引用。提醒一下，对于任何具有可分配给  BeanFactoryPostProcessor 的返回类型的非静态  @Bean 方法，都会发出一条 INFO 级别的日志消息。

## @Bean 源码解析

