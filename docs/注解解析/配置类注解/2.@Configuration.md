# 2.@Configuration
[toc]

# @Configuration
## 简介
是Spring的配置类注解，为@Component的衍生注解，语义不同，在Spring中语义为配置类的意思，在@Configuration类下，可以声明@Bean方法，默认作为Full模式的CONFIGURATION_CLASS被加载
## 属性解析
```java
public @interface Configuration {
	//是@Component的扩展注解，代表这个组件为一个配置类
	@AliasFor(annotation = Component.class)
	String value() default "";
	//默认为true，代表配置为full模式配置类，设置为false，那么配置类为lite模式
	boolean proxyBeanMethods() default true;

}

```

## Full与Lite模式
在ConfigurationClassPostProcessors#processConfigBeanDefinitions中，我们会解析当前配置类，代码如下：
```java
//传入的配置类
for (String beanName : candidateNames) {
	//在registry步骤的时候，就会将配置类的bean definition生成放入beanDefinitionMap
	BeanDefinition beanDef = registry.getBeanDefinition(beanName);
	//如果还未配置过configurationClass，会进入else，查找是否打了@Configuration，打了就会存入configurationClass属性，将类作为配置类加载
	if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {
		if (logger.isDebugEnabled()) {
			logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
		}
	}
	//筛选出打了把我们的配置类放入configCandidates,找doRegisterBean中注册的AnnotatedGenericBeanDefinition
	//就是开发人员自己传入的配置类
	else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
		configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
	}
}
```
当我们的传入的配置类，打了@Configuraion注解，那么就会被方法`checkConfigurationClassCandidate`解析，当配置类打了@Configuraion，会被解析成CONFIGURATION_CLASS_FULL，否则会解析为CONFIGURATION_CLASS_LITE。


解析设置代码ConfigurationClassUtils#checkConfigurationClassCandidate：
```java
		//打了@Configuration，没有设置proxyBeanMethods，设置CONFIGURATION_CLASS_ATTRIBUTE=FULL
		if (config != null && !Boolean.FALSE.equals(config.get("proxyBeanMethods"))) {
			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
		}
		//如果打了@Configuration，且设置了proxyBeanMethods=false，设置CONFIGURATION_CLASS_ATTRIBUTE=LITE
		//打了Component/ComponentScan/Import/ImportResource，也设置为LITE模式
		else if (config != null || isConfigurationCandidate(metadata)) {
			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
		}
		else {
			return false;
		}
```
- @Component/@ComponentScan/@Import/@ImportResource：CONFIGURATION_CLASS_LITE
  - 配置类本身不会被CGLIB增强，放进IoC容器内的就是类本身
  - 对于内部类是没有限制的：可以是Full模式或者Lite模式
  - 配置类内部不能通过方法调用来处理依赖，否则每次生成的都是一个新实例而并非IoC容器内的单例
  - 配置类就是一普通类，所以@Bean方法可以使用private/final等进行修饰
```java
//说明这是一个lite模式
@Component  
public class LiteConfig {
    @Bean
    public User userA() {
        User user= new User ();
        user.setName("userA");
        return user;
    }
    //可以是private的方法
    @Bean
    private User userB() {
        User user= new User ();
        user.setName("userB");
        //lite模式下:调用userA()方法会生成一个新的Bean
        System.out.println("userB1:"+System.identityHashCode(userA()));
        System.out.println("userB2:"+System.identityHashCode(userA()));
        //返回false
        System.out.println("userB3:"+(userA()== userA()));
        return user;
    }
	//内部类可以是任意模式
    private static class InnerConfig {
        @Bean
        //lit模式下方法可以使用private final修饰
        private final User userInner() { 
            User user= new User ();
            user.setName("userInner");
            return user;
        }
    }
}

```
- @Configuraion：CONFIGURATION_CLASS_FULL
	- 配置类会被CGLIB增强(生成代理对象)，放进IoC容器内的是代理
	- 对于内部类是没有限制的：可以是Full模式或者Lite模式
	- 配置类内部可以通过方法调用来处理依赖，并且能够保证是同一个实例，都指向IoC内的那个单例
	- @Bean方法不能被private/final等进行修饰，因为代理类需要重写这个方法
```java
@Configuration
public class FullConfig {
    @Bean
    public Student studentA() {
        Student student = new Student();
        student.setName("StudentA");
        return student;
    }
    @Bean
    public Student studentB() {
        System.out.println("------------------full------------------");
        Student student = new Student();
        student.setName("StudentB");
        //full模式下：调用StudentA()多少次都是返回容器中注入的同一个Bean
        System.out.println("StudentB1:"+System.identityHashCode(studentA()));
        System.out.println("StudentB2:"+System.identityHashCode(studentA()));
        System.out.println("StudentB3:"+(studentA()== studentA())); //true

        return student;
    }
    private static class InnerConfig {
        @Bean
        public final Student studentInner() {
            Student student = new Student();
            student.setName("StudentInner");
            return student;
        }
    }
}

```

## Full与Lite源码解析
### Full源码解析
ConfigurationClassPostProcessor#postProcessBeanFactory
```java
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        ...
		//enhance增强代理Full的配置类
		enhanceConfigurationClasses(beanFactory);
		beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
	}
```
ConfigurationClassEnhancer#enhance，在创建代理类的时候，是基于每个BeanDefinition进行创建
```java
for (Map.Entry<String, AbstractBeanDefinition> entry :configBeanDefs.entrySet()) {
	AbstractBeanDefinition beanDef = entry.getValue();
	//如果 @Configuration 类被代理，总是代理目标类
	beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
	//设置用户指定bean类的增强子类
	Class<?> configClass = beanDef.getBeanClass();
	//代理增增强逻辑
	Class<?> enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
	if (configClass != enhancedClass) {
		beanDef.setBeanClass(enhancedClass);
	}
}
```
针对Configuration_Class的代理，增强逻辑位于ConfigurationClassEnhancer，
```java
//代理逻辑
private static final Callback[] CALLBACKS = new Callbac[] {
		new BeanMethodInterceptor(),
		new BeanFactoryAwareMethodInterceptor(),
		NoOp.INSTANCE
};
private static final ConditionalCallbackFilterCALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS;
```
返回的CGLIB代理实例：
```java
	private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {
		Enhancer enhancer = new Enhancer();
		enhancer.setSuperclass(configSuperClass);
		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class});
		enhancer.setUseFactory(false);
		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
		enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
		enhancer.setCallbackFilter(CALLBACK_FILTER);
		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
		return enhancer;
	}
```
调用Full模式代理增强的时候，会按照配置的CALLBACKS，依次执行BeanMethodInterceptor#intercept/BeanFactoryAwareMethodInterceptor#intercept。调用BeanMethodInterceptor#resolveBeanReference#361L，beanFactory.getBean(beanName)方法获取Spring中的Bean，shi y
### Lite源码解析
Lite模式中，@Bean标注的方法，Spring作为普通方法处理，并没有进行增强处理


## 小结
经过上文对Full与Lite的解析，总结出：若我们不需要Spring对我们@Bean的方法进行代理，而是作为普通类处理，那么就需要将其声明为Lite模式，Spring中之会有这两种模式，个人认为是，Spring为了让调用@Bean方法被调用，产生出来的对象，保持全局一致，兼容以下写法：

```java
@Configuration
public class DaoConfig {
    @Bean
    public DataSource dataSource() {
        return new MysqlDataSource();
    }
    @Bean
    public SqlSessionFactoryBean sqlMapClientWrite() throws Exception {
        ...
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource());
        ...
    }
}
```
如上代码中，DaoConfig类，标注了@Configuration，说明其为Full模式，那么这种写法不会出现问题，spring对dataSource()方法进行了代理，` bean.setDataSource(dataSource());`调用的时候，set进去的是Spring为其生成的代理对象，setDataSource设置的dataSource与Spring容器中的对象一致，不会产生2个对象。但是如果我们写法为：`@Configuration(proxyBeanMethods = false)`或者为`@Component`，将Configuration_Class设置为Lite模式，上面写法就会产生问题，Spring将 @Bean当作普通方法处理，没有进行代理，导致Spring容器中的对象与SqlSessionFactoryBean中放的对象不是同一个，这时候需要换写法：
```java
@Configuration(proxyBeanMethods = false)
public class DaoConfig {
    @Bean
    public DataSource dataSource() {
        return new MysqlDataSource();
    }
    @Bean
    public SqlSessionFactoryBean sqlMapClientWrite(DataSource dataSource) throws Exception {
        ...
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        ...
    }
}
```
将dataSource作为方法的入参，Spring在属性注入的时候，会默认获取name为dataSource的bean，传给方法，对sqlMapClientWrite进行初始化。

个人建议使用Lite模式的Configuration_Class，写法比较通熟易懂，也较为容易调试，在Spring5.2/SpringBoot 2.2版本后，Spring在@Configuration注解中添加了属性proxyBeanMethod，可以设置为false，使得我们可以既兼容@Configuration的语义，又可以配置Configuration_Class为Lite