# @Configuration
[toc]

## 简介
是Spring的配置类注解，在@Configuration类下，可以声明@Bean方法，默认作为Full模式的CONFIGURATION_CLASS被加载，一般与@ComponentScan配合使用
## 属性解析
```java
public @interface Configuration {
	//是@Component的扩展注解，代表这个组件为一个配置类
	@AliasFor(annotation = Component.class)
	String value() default "";
	//默认为true，代表配置为full模式配置类，设置为false，那么配置类为lite模式
	boolean proxyBeanMethods() default true;

}

```

## Full与Lite模式

在ConfigurationClassPostProcessors#processConfigBeanDefinitions中，我们会解析当前配置类，代码如下：
```java
//传入的配置类
for (String beanName : candidateNames) {
	//在registry步骤的时候，就会将配置类的bean definition生成放入beanDefinitionMap
	BeanDefinition beanDef = registry.getBeanDefinition(beanName);
	//如果还未配置过configurationClass，会进入else，查找是否打了@Configuration，打了就会存入configurationClass属性，将类作为配置类加载
	if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {
		if (logger.isDebugEnabled()) {
			logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
		}
	}
	//筛选出打了把我们的配置类放入configCandidates,找doRegisterBean中注册的AnnotatedGenericBeanDefinition
	//就是开发人员自己传入的配置类
	else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
		configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
	}
}
```
当我们的传入的配置类，打了@Configuraion注解，那么就会被方法`checkConfigurationClassCandidate`解析，当配置类打了@Configuraion，会被解析成CONFIGURATION_CLASS_FULL，否则会解析为CONFIGURATION_CLASS_LITE。

- @Component/@ComponentScan/@Import/@ImportResource：CONFIGURATION_CLASS_LITE
  - 配置类本身不会被CGLIB增强，放进IoC容器内的就是类本身
  - 对于内部类是没有限制的：可以是Full模式或者Lite模式
  - 配置类内部不能通过方法调用来处理依赖，否则每次生成的都是一个新实例而并非IoC容器内的单例
  - 配置类就是一普通类，所以@Bean方法可以使用private/final等进行修饰
```java
//说明这是一个lite模式
@Component  
public class LiteConfig {
    @Bean
    public User userA() {
        User user= new User ();
        user.setName("userA");
        return user;
    }
    //可以是private的方法
    @Bean
    private User userB() {
        User user= new User ();
        user.setName("userB");
        //lite模式下:调用userA()方法会生成一个新的Bean
        System.out.println("userB1:"+System.identityHashCode(userA()));
        System.out.println("userB2:"+System.identityHashCode(userA()));
        //返回false
        System.out.println("userB3:"+(userA()== userA()));
        return user;
    }
	//内部类可以是任意模式
    private static class InnerConfig {
        @Bean
        //lit模式下方法可以使用private final修饰
        private final User userInner() { 
            User user= new User ();
            user.setName("userInner");
            return user;
        }
    }
}

```


- @Configuraion：CONFIGURATION_CLASS_FULL
	- 配置类会被CGLIB增强(生成代理对象)，放进IoC容器内的是代理
	- 对于内部类是没有限制的：可以是Full模式或者Lite模式
	- 配置类内部可以通过方法调用来处理依赖，并且能够保证是同一个实例，都指向IoC内的那个单例
	- @Bean方法不能被private/final等进行修饰，因为代理类需要重写这个方法
```java
@Configuration
public class FullConfig {
    @Bean
    public User userA() {
        User user = new User();
        user.setName("userA");
        return user;
    }
    @Bean
    public User userB() {
        User user = new User();
        user.setName("userB");
        //full模式下：调用userA()多少次都是返回容器中注入的同一个Bean
        System.out.println("userB1:"+System.identityHashCode(userA()));
        System.out.println("userB2:"+System.identityHashCode(userA()));
        System.out.println("userB3:"+(userA()== userA())); //true

        return user;
    }
    private static class InnerConfig {
        @Bean
        public final User userInner() {
            User user = new User();
            user.setName("userInner");
            return user;
        }
    }
}

```

## 小结

Repeatable可以将多个注解合并成一个注解

